{{ file_header }}
{% if plugin_imports %}

{% for import in plugin_imports %}
import {{ import }}
{% endfor %}
{% endif %}

/**
 PURPOSE:
 Declares the dependencies required by this Plugin that will be injected (not created by this Plugin itself).
 */
public protocol {{ plugin_name }}PluginDependency: Dependency {}

/**
 PURPOSE:
 Declares dependencies that are owned by this Plugin.
 */
internal final class {{ plugin_name }}PluginComponent: Component
<
    {{ plugin_name }}PluginDependency
> {

    /*
     Dependencies
     ============

     Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

     fileprivate let example: Example = .init()

     Whenever possible, for example when the dependency does not provide shared state, define the property as a
     factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
     Needle compatibility whenever the access control is increased.

     fileprivate var exampleFactory: Example {
         Example()
     }

     When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
     that always returns the same instance from a computed property.

     fileprivate var example: Example {
         shared { Example(otherDependency: dependency.otherDependency) }
     }

     */

    /*
     Child Components
     ================

     Declare child component factories as 'fileprivate' methods.

     fileprivate func <name>ComponentFactory() -> <Name>Component {
         <Name>Component(parent: self)
     }

     */
    {% if not return_type %}

    fileprivate func componentFactory() -> {{ plugin_name }}Component {
        {{ plugin_name }}Component(parent: self)
    }
    {% endif %}
}

/**
 PURPOSE:
 To provide additional state used in determining if the Plugin is enabled (can be any type relevant to the Plugin).
 */
internal typealias {{ plugin_name }}PluginStateType = Void

/**
 PURPOSE:
 The Plugin interface (available to mock for testability).
 */
internal protocol {{ plugin_name }}Plugin {
    {% if return_type %}
    func create() -> {{ return_type }}?
    {% else %}
    func create() -> {{ plugin_name }}Builder?
    {% endif %}
}

/**
 PURPOSE:
 Concrete implementation of the Plugin.
 */
internal final class {{ plugin_name }}PluginImp: Plugin
<
    {{ plugin_name }}PluginComponent,
    {% if return_type %}
    {{ return_type }},
    {% else %}
    {{ plugin_name }}Builder,
    {% endif %}
    {{ plugin_name }}PluginStateType
> {

    /// The method in which the Plugin's enabled criteria is defined.
    /// - Parameters:
    ///   - component: The component instance
    ///   - state: The state
    /// - Returns: The enabled status of the Plugin
    override internal func isEnabled(
        component: {{ plugin_name }}PluginComponent,
        state: {{ plugin_name }}PluginStateType
    ) -> Bool {
        false
    }

    /// The factory method in which the instance is initialized.
    /// - Parameter component: The component instance
    /// - Returns: The initialized instance
    override internal func build(
        component: {{ plugin_name }}PluginComponent
    {% if return_type %}
    ) -> {{ return_type }} {
        // TODO: Initialize instance
    {% else %}
    ) -> {{ plugin_name }}Builder {
        {{ plugin_name }}BuilderImp(componentFactory: component.componentFactory)
    {% endif %}
    }
}

extension {{ plugin_name }}PluginImp: {{ plugin_name }}Plugin {}
