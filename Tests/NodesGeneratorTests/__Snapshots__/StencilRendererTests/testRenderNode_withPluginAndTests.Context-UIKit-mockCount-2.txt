//<fileHeader>

import <contextImport1>
import <contextImport2>

/// PURPOSE:
/// The Context delegates callbacks to its (external) Listener, typically the parent Context.
/// @mockable
@MainActor
internal protocol <nodeName>Listener: AnyObject {}

/// PURPOSE:
/// The interface that the Context will speak to the Flow through. Used to initiate navigation as
/// an example.
/// @mockable
@MainActor
internal protocol <nodeName>FlowInterface: Flow {}

/// PURPOSE:
/// Contains the business logic of the Node. The lifecycle of the Node is bookended between the
/// `didBecomeActive` and `willResignActive` methods.
internal final class <nodeName>ContextImp: AbstractContext
<
    <contextGenericType1>,
    <contextGenericType2>
> {

    // periphery:ignore
    /// The Flow instance.
    internal weak var flow: <nodeName>FlowInterface?

    // periphery:ignore
    /// The Listener instance.
    internal weak var listener: <nodeName>Listener?

    /// The Store instance.
    private let store: Any<storePrefix>StateStore<<nodeName>State>

    // periphery:ignore
    /// The Analytics instance.
    private let analytics: <nodeName>Analytics

    /// The initializer.
    /// - Parameters:
    ///   - workers: The Worker instances
    ///   - store: The Store instance
    ///   - analytics: The Analytics instance
    internal init<T: <storePrefix>StateStore>(
        workers: [Worker],
        store: T,
        analytics: <nodeName>Analytics
    ) where T.State == <nodeName>State {
        self.store = Any<storePrefix>StateStore(store)
        self.analytics = analytics
        super.init(workers: workers)
    }

    /// Implement logic to execute when the Context becomes active.
    override internal func didBecomeActive() {}

    /// Implement logic to execute when the Context will become inactive.
    override internal func willResignActive() {}
}

extension <nodeName>ContextImp: <nodeName>ContextInterface {}
extension <nodeName>ContextImp: <nodeName>Receiver {}
