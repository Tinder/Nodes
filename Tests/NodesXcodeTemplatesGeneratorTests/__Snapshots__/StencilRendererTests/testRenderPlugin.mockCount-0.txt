<fileHeader>

public protocol <pluginName>PluginDependency: Dependency {}

public final class <pluginName>PluginComponent: Component
<
    <pluginName>PluginDependency
> {

    /*
     Dependencies
     ============

     Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

     fileprivate let example: Example = .init()

     Whenever possible, for example when the dependency does not provide shared state, define the property as a
     factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
     Needle compatibility whenever the access control is increased.

     fileprivate var exampleFactory: Example {
         Example()
     }

     When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
     that always returns the same instance from a computed property.

     fileprivate var example: Example {
         shared { Example(otherDependency: dependency.otherDependency) }
     }

     */

    /*
     Child Components
     ================

     Declare child component factories as 'fileprivate' methods.

     fileprivate func <name>ComponentFactory() -> <Name>Component {
         <Name>Component(parent: self)
     }

     */
}

internal typealias <pluginName>PluginStateType = Void

internal protocol <pluginName>Plugin {
    func create() -> <returnType>?
}

internal final class <pluginName>PluginImp: Plugin
<
    <pluginName>PluginComponent,
    <returnType>,
    <pluginName>PluginStateType
> {

    override internal func isEnabled(
        component: <pluginName>PluginComponent,
        state: <pluginName>PluginStateType
    ) -> Bool {
        false
    }

    override internal func build(
        component: <pluginName>PluginComponent
    ) -> <returnType> {
        // TODO: Initialize instance
    }
}

extension <pluginName>PluginImp: <pluginName>Plugin {}
