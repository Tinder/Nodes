<fileHeader>

import <flowImports>

/**
 PURPOSE:
 The interface that the Flow will speak to the Context through. Used for informing the Context of
 presentation lifecycle events, as an example.
 */
internal protocol RootContextInterface: Context {
    var flow: RootFlowInterface? { get set }
    var listener: RootListener? { get }
}

/**
 PURPOSE:
 The interface of the View used for presenting the View of child Nodes. May inherit additional base
 protocols to add further pre-baked presentation behavior and/or add new methods for custom presentation
 implementation as necessary.
 */
internal protocol RootViewControllable: <viewControllableType> {}

/**
 PURPOSE:
 Responsible for presenting views and starting child Flows, and should not contain business logic.
 */
internal final class RootFlowImp: AbstractFlow
    <RootContextInterface, RootViewControllable> {

    /// Provides the parent Node with access to the View so it can be presented.
    internal var viewControllable: <viewControllableType> {
        viewController
    }

    private let <flowPropertiesName>: <flowPropertiesType>

    /// The initializer.
    ///
    /// Inject Plugins or Builders into the Flow in order to create sub-Flows.
    /// - Parameters:
    ///   - context: The Context instance
    ///   - viewController: The View Controller instance
    ///   - <flowPropertiesName>: The <flowPropertiesType> instance
    internal init(
        context: RootContextInterface,
        viewController: RootViewControllable,
        <flowPropertiesName>: <flowPropertiesType>
    ) {
        self.<flowPropertiesName> = <flowPropertiesName>
        super.init(context: context, viewController: viewController)
        context.flow = self
    }

    /// Implement logic to execute when the Flow is started.
    override internal func didStart() {}
}

extension RootFlowImp: RootFlow {}
extension RootFlowImp: RootFlowInterface {

    /// Implement logic to execute when the Root Flow is ready to attach sub-Flows.
    internal func didBecomeReady() {}
}
