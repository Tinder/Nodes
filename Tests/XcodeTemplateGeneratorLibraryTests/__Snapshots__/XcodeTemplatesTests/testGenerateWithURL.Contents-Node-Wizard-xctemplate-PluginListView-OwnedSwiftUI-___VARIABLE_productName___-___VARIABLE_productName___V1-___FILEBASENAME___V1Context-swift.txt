//___FILEHEADER___

import Combine
import Nodes

/**
 PURPOSE:
 The Context delegates callbacks to its (external) Listener, typically the parent Context.
 */
internal protocol ___VARIABLE_productName___V1Listener: AnyObject {}

/**
 PURPOSE:
 The interface that the Context will speak to the Flow through. Used to initiate navigation as
 an example.
 */
internal protocol ___VARIABLE_productName___V1FlowInterface: Flow {}

/**
 PURPOSE:
 Contains the business logic of the Node. The lifecycle of the Node is bookended between the
 `didBecomeActive` and `willResignActive` methods.
 */
internal final class ___VARIABLE_productName___V1ContextImp: AbstractContext
<
    AnyCancellable
> {

    /// The Flow instance.
    internal weak var flow: ___VARIABLE_productName___V1FlowInterface?

    /// The Listener instance.
    internal weak var listener: ___VARIABLE_productName___V1Listener?

    /// The State instance.
    @Published internal private(set) var state: ___VARIABLE_productName___V1State

    /// The Analytics instance.
    private let analytics: ___VARIABLE_productName___V1Analytics

    /// The initializer.
    /// - Parameters:
    ///   - workers: The Worker instances
    ///   - analytics: The Analytics instance
    internal init(
        workers: [Worker],
        analytics: ___VARIABLE_productName___V1Analytics
    ) {
        self.state = ___VARIABLE_productName___V1State()
        self.analytics = analytics
        super.init(workers: workers)
    }

    /// Implement logic to execute when the Context becomes active.
    override internal func didBecomeActive() {}

    /// Implement logic to execute when the Context will become inactive.
    override internal func willResignActive() {}

    deinit {
        LeakDetector.detect(analytics)
    }
}

extension ___VARIABLE_productName___V1ContextImp: ___VARIABLE_productName___V1ContextInterface {}
extension ___VARIABLE_productName___V1ContextImp: ___VARIABLE_productName___V1Receiver {}
