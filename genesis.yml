options:

  - question: "Nodes Version Requirement (up to next major):"
    name: nodes
    type: string
    required: true

  - question: "Project Name:"
    name: project
    type: string
    required: true

  - question: "Organization Identifier (the bundle ID prefix):"
    name: prefix
    type: string
    required: true

  - question: "Author Name (for source file attribution):"
    name: author
    type: string
    required: true

  - question: "Today's Date (for source file attribution):"
    name: date
    type: string
    required: true

files:

  - path: .gitignore
    contents: |
      # macOS
      .DS_Store

      # SPM
      .swiftpm/
      .build/

      # Xcode
      *.xcworkspace/
      *.xcodeproj/

  - path: .swiftlint-rules.yml
    contents: |
      analyzer_rules:
      - capture_variable
      # - explicit_self
      - typesafe_array_init
      # - unused_declaration
      - unused_import

      only_rules:
      - accessibility_label_for_image
      - accessibility_trait_for_button
      - anonymous_argument_in_multiline_closure
      - anyobject_protocol
      - array_init
      - attributes
      - balanced_xctest_lifecycle
      - blanket_disable_command
      - block_based_kvo
      - class_delegate_protocol
      - closing_brace
      - closure_body_length
      - closure_end_indentation
      - closure_parameter_position
      - closure_spacing
      - collection_alignment
      - colon
      - comma
      - comma_inheritance
      - comment_spacing
      - compiler_protocol_init
      - computed_accessors_order
      - conditional_returns_on_newline
      - contains_over_filter_count
      - contains_over_filter_is_empty
      - contains_over_first_not_nil
      - contains_over_range_nil_comparison
      - control_statement
      - convenience_type
      - custom_rules
      - cyclomatic_complexity
      - deployment_target
      - direct_return
      - discarded_notification_center_observer
      - discouraged_assert
      - discouraged_direct_init
      - discouraged_none_name
      - discouraged_object_literal
      - discouraged_optional_boolean
      - discouraged_optional_collection
      - duplicate_conditions
      - duplicate_enum_cases
      - duplicate_imports
      - duplicated_key_in_dictionary_literal
      - dynamic_inline
      - empty_collection_literal
      - empty_count
      - empty_enum_arguments
      - empty_parameters
      - empty_parentheses_with_trailing_closure
      - empty_string
      - empty_xctest_method
      - enum_case_associated_values_count
      - expiring_todo
      - explicit_acl
      - explicit_enum_raw_value
      - explicit_init
      - explicit_top_level_acl
      - explicit_type_interface
      # - extension_access_modifier
      - fallthrough
      - fatal_error_message
      - file_header
      - file_length
      # - file_name
      - file_name_no_space
      # - file_types_order
      - first_where
      - flatmap_over_map_reduce
      - for_where
      - force_cast
      - force_try
      - force_unwrapping
      - function_body_length
      - function_default_parameter_at_end
      - function_parameter_count
      - generic_type_name
      - given_when_then # custom_rule
      - ibinspectable_in_extension
      - identical_operands
      - identifier_name
      - implicit_getter
      - implicit_return
      - implicitly_unwrapped_optional
      - inclusive_language
      # - indentation_width
      - inert_defer
      - invalid_swiftlint_command
      - is_disjoint
      - joined_default_parameter
      - large_tuple
      - last_where
      - leading_whitespace
      - legacy_cggeometry_functions
      - legacy_constant
      - legacy_constructor
      - legacy_hashing
      - legacy_multiple
      - legacy_nsgeometry_functions
      - legacy_objc_type
      - legacy_random
      - let_var_whitespace
      - line_length
      - literal_expression_end_indentation
      - local_doc_comment
      - lower_acl_than_parent
      - mark
      # - missing_docs
      - modifier_order
      - multiline_arguments
      # - multiline_arguments_brackets
      - multiline_function_chains
      - multiline_literal_brackets
      - multiline_parameters
      - multiline_parameters_brackets
      - multiple_closures_with_trailing_closure
      - nesting
      - nimble_operator
      - no_extension_access_modifier
      - no_fallthrough_only
      # - no_grouping_extension
      # - no_magic_numbers
      - no_space_in_method_call
      - notification_center_detachment
      - ns_number_init_as_function_reference
      - nslocalizedstring_key
      - nslocalizedstring_require_bundle
      - nsobject_prefer_isequal
      - number_separator
      # - object_literal
      - opening_brace
      - operator_usage_whitespace
      - operator_whitespace
      - optional_enum_case_matching
      - orphaned_doc_comment
      - overridden_super_call
      - override_in_extension
      - pattern_matching_keywords
      - period_spacing
      - prefer_nimble
      - prefer_self_in_static_references
      - prefer_self_type_over_type_of_self
      - prefer_zero_over_explicit_init
      # - prefixed_toplevel_constant
      - private_action
      - private_outlet
      - private_over_fileprivate
      - private_subject
      - private_unit_test
      - prohibited_interface_builder
      - prohibited_super_call
      - protocol_property_accessors_order
      - quick_discouraged_call
      - quick_discouraged_focused_test
      - quick_discouraged_pending_test
      - raw_value_for_camel_cased_codable_enum
      - reduce_boolean
      - reduce_into
      - redundant_discardable_let
      - redundant_nil_coalescing
      - redundant_objc_attribute
      - redundant_optional_initialization
      - redundant_self_in_closure
      - redundant_set_access_control
      # - redundant_string_enum_value
      - redundant_type_annotation
      - redundant_void_return
      # - required_deinit
      - required_enum_case
      - return_arrow_whitespace
      # - return_value_from_void_function
      - self_binding
      - self_in_property_initialization
      - shorthand_operator
      - shorthand_optional_binding
      - single_test_class
      # - sorted_enum_cases
      - sorted_first_last
      - sorted_imports
      - statement_position
      - static_operator
      # - strict_fileprivate
      - strong_iboutlet
      - superfluous_disable_command
      - superfluous_else
      - switch_case_alignment
      - switch_case_on_newline
      - syntactic_sugar
      - test_case_accessibility
      - todo
      - toggle_bool
      - trailing_closure
      - trailing_comma
      - trailing_newline
      - trailing_semicolon
      - trailing_whitespace
      - type_body_length
      # - type_contents_order
      - type_name
      - unavailable_condition
      - unavailable_function
      - unhandled_throwing_task
      - unneeded_break_in_switch
      - unneeded_parentheses_in_closure_argument
      - unneeded_synthesized_initializer
      - unowned_variable_capture
      - untyped_error_in_catch
      - unused_capture_list
      - unused_closure_parameter
      - unused_control_flow_label
      - unused_enumerated
      - unused_optional_binding
      - unused_setter_value
      - valid_ibinspectable
      - vertical_parameter_alignment
      - vertical_parameter_alignment_on_call
      - vertical_whitespace
      # - vertical_whitespace_between_cases
      # - vertical_whitespace_closing_braces
      # - vertical_whitespace_opening_braces
      - void_function_in_ternary
      - void_return
      - weak_delegate
      - xct_specific_matcher
      - xctfail_message
      - yoda_condition

  - path: .swiftlint.yml
    contents: |
      included:
      - {{ project|split:' '|join:'_' }}/Sources
      - {{ project|split:' '|join:'_' }}Tests/Tests

      excluded:
      - {{ project|split:' '|join:'_' }}/Generated
      - {{ project|split:' '|join:'_' }}Tests/Generated

      child_config: .swiftlint-rules.yml

      empty_count:
        only_after_dot: true

      file_header:
        required_pattern: |
          \/\/
          \/\/ {2}.+\.swift
          \/\/ {2}.+
          \/\/
          \/\/ {2}Created by .+ on \d{1,2}\/\d{1,2}\/\d{2}\.
          \/\/

      private_over_fileprivate:
        validate_extensions: true

      trailing_whitespace:
        ignores_comments: false

      type_name:
        max_length: 50

      custom_rules:
        given_when_then:
          name: GIVEN / WHEN / THEN
          message: |
            "GIVEN / WHEN / THEN" comments must be uppercase, without punctuation and both preceded and followed by an empty line.
          regex: |
            ((?<=\n) +\/\/ (Given|given|When|when|Then|then)(?= *\n))|((?<=\n) +[^ ]\/\/ (GIVEN|WHEN|THEN))|((?<=\n) +\/\/  +(GIVEN|WHEN|THEN))|((?<=[^\n]\n) +\/\/ (GIVEN|WHEN|THEN))|((?<=\n) +\/\/ (GIVEN|WHEN|THEN)(?!\n\n))

  - path: BuildSettings/Debug.xcconfig
    contents: |
      #include "Shared.xcconfig"

      DEBUG_INFORMATION_FORMAT = dwarf
      ENABLE_TESTABILITY = YES
      GCC_DYNAMIC_NO_PIC = NO
      GCC_OPTIMIZATION_LEVEL = 0
      GCC_PREPROCESSOR_DEFINITIONS = DEBUG=1
      MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE
      ONLY_ACTIVE_ARCH = YES
      SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG
      SWIFT_OPTIMIZATION_LEVEL = -Onone

  - path: BuildSettings/Release.xcconfig
    contents: |
      #include "Shared.xcconfig"

      DEBUG_INFORMATION_FORMAT = dwarf-with-dsym
      ENABLE_NS_ASSERTIONS = NO
      MTL_ENABLE_DEBUG_INFO = NO
      SWIFT_COMPILATION_MODE = wholemodule
      SWIFT_OPTIMIZATION_LEVEL = -O
      VALIDATE_PRODUCT = YES

  - path: BuildSettings/Shared.xcconfig
    contents: |
      ALWAYS_SEARCH_USER_PATHS = NO
      CLANG_ANALYZER_NONNULL = YES
      CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE
      CLANG_CXX_LANGUAGE_STANDARD = gnu++14
      CLANG_CXX_LIBRARY = libc++
      CLANG_ENABLE_MODULES = YES
      CLANG_ENABLE_OBJC_ARC = YES
      CLANG_ENABLE_OBJC_WEAK = YES
      CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
      CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES
      CLANG_WARN_BOOL_CONVERSION = YES
      CLANG_WARN_COMMA = YES
      CLANG_WARN_CONSTANT_CONVERSION = YES
      CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES
      CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR
      CLANG_WARN_DOCUMENTATION_COMMENTS = YES
      CLANG_WARN_EMPTY_BODY = YES
      CLANG_WARN_ENUM_CONVERSION = YES
      CLANG_WARN_INFINITE_RECURSION = YES
      CLANG_WARN_INT_CONVERSION = YES
      CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES
      CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
      CLANG_WARN_OBJC_LITERAL_CONVERSION = YES
      CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR
      CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES
      CLANG_WARN_RANGE_LOOP_ANALYSIS = YES
      CLANG_WARN_STRICT_PROTOTYPES = YES
      CLANG_WARN_SUSPICIOUS_MOVE = YES
      CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
      CLANG_WARN_UNREACHABLE_CODE = YES
      COPY_PHASE_STRIP = NO
      ENABLE_STRICT_OBJC_MSGSEND = YES
      GCC_C_LANGUAGE_STANDARD = gnu11
      GCC_NO_COMMON_BLOCKS = YES
      GCC_WARN_64_TO_32_BIT_CONVERSION = YES
      GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR
      GCC_WARN_UNDECLARED_SELECTOR = YES
      GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE
      GCC_WARN_UNUSED_FUNCTION = YES
      GCC_WARN_UNUSED_VARIABLE = YES
      MTL_FAST_MATH = YES
      SDKROOT = iphoneos
      SWIFT_STRICT_CONCURRENCY = complete

  - path: "{{ project|split:' '|join:'_' }}/Assets/Assets.xcassets/AccentColor.colorset/Contents.json"
    contents: |
      {
        "colors" : [
          {
            "idiom" : "universal"
          }
        ],
        "info" : {
          "author" : "xcode",
          "version" : 1
        }
      }

  - path: "{{ project|split:' '|join:'_' }}/Assets/Assets.xcassets/AppIcon.appiconset/Contents.json"
    contents: |
      {
        "images" : [
          {
            "idiom" : "iphone",
            "scale" : "2x",
            "size" : "20x20"
          },
          {
            "idiom" : "iphone",
            "scale" : "3x",
            "size" : "20x20"
          },
          {
            "idiom" : "iphone",
            "scale" : "2x",
            "size" : "29x29"
          },
          {
            "idiom" : "iphone",
            "scale" : "3x",
            "size" : "29x29"
          },
          {
            "idiom" : "iphone",
            "scale" : "2x",
            "size" : "40x40"
          },
          {
            "idiom" : "iphone",
            "scale" : "3x",
            "size" : "40x40"
          },
          {
            "idiom" : "iphone",
            "scale" : "2x",
            "size" : "60x60"
          },
          {
            "idiom" : "iphone",
            "scale" : "3x",
            "size" : "60x60"
          },
          {
            "idiom" : "ipad",
            "scale" : "1x",
            "size" : "20x20"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "20x20"
          },
          {
            "idiom" : "ipad",
            "scale" : "1x",
            "size" : "29x29"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "29x29"
          },
          {
            "idiom" : "ipad",
            "scale" : "1x",
            "size" : "40x40"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "40x40"
          },
          {
            "idiom" : "ipad",
            "scale" : "1x",
            "size" : "76x76"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "76x76"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "83.5x83.5"
          },
          {
            "idiom" : "ios-marketing",
            "scale" : "1x",
            "size" : "1024x1024"
          }
        ],
        "info" : {
          "author" : "xcode",
          "version" : 1
        }
      }

  - path: "{{ project|split:' '|join:'_' }}/Assets/Assets.xcassets/Contents.json"
    contents: |
      {
        "info" : {
          "author" : "xcode",
          "version" : 1
        }
      }

  - path: "{{ project|split:' '|join:'_' }}/BuildSettings/Debug.xcconfig"
    contents: |
      #include "Shared.xcconfig"

  - path: "{{ project|split:' '|join:'_' }}/BuildSettings/Release.xcconfig"
    contents: |
      #include "Shared.xcconfig"

  - path: "{{ project|split:' '|join:'_' }}/BuildSettings/Shared.xcconfig"
    contents: |
      ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon
      ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor
      CODE_SIGN_STYLE = Automatic
      LD_RUNPATH_SEARCH_PATHS = $(inherited) @executable_path/Frameworks
      PRODUCT_NAME = $(TARGET_NAME)
      SWIFT_VERSION = 5.0
      TARGETED_DEVICE_FAMILY = 1,2

  - path: "{{ project|split:' '|join:'_' }}/Generated/.gitignore"
    contents: |
      *
      !.gitignore

  - path: "{{ project|split:' '|join:'_' }}/Resources/Base.lproj/LaunchScreen.storyboard"
    contents: |
      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
      <document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13122.16" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
          <dependencies>
              <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13104.12"/>
              <capability name="Safe area layout guides" minToolsVersion="9.0"/>
              <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
          </dependencies>
          <scenes>
              <!--View Controller-->
              <scene sceneID="EHf-IW-A2E">
                  <objects>
                      <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                          <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                              <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                              <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                              <color key="backgroundColor" xcode11CocoaTouchSystemColor="systemBackgroundColor" cocoaTouchSystemColor="whiteColor"/>
                              <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                          </view>
                      </viewController>
                      <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
                  </objects>
                  <point key="canvasLocation" x="53" y="375"/>
              </scene>
          </scenes>
      </document>

  - path: "{{ project|split:' '|join:'_' }}/Sources/AppDelegate.swift"
    contents: |
      //
      //  AppDelegate.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import UIKit

      @main
      internal final class AppDelegate: UIResponder, UIApplicationDelegate {

          private lazy var appBuilder: AppBuilder = AppBuilderImp { AppComponent() }
          private lazy var appFlow: AppFlow = appBuilder.build()

          internal convenience init(appBuilder: AppBuilder) {
              self.init()
              self.appBuilder = appBuilder
          }

          internal func application(
              _ application: UIApplication, // swiftlint:disable:next discouraged_optional_collection
              didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
          ) -> Bool {
              bootstrap()
              return true
          }

          private func bootstrap() {
              #if DEBUG
              guard appBuilder is AppBuilderImp
              else { return appFlow.start() }
              guard NSClassFromString("XCTestCase") == nil
              else { return }
              #endif
              registerProviderFactories()
              appFlow.start()
          }
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/SceneDelegate.swift"
    contents: |
      //
      //  SceneDelegate.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import UIKit

      internal final class SceneDelegate: UIResponder, UIWindowSceneDelegate {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/1 App/AppAnalytics.swift"
    contents: |
      //
      //  AppAnalytics.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /*
       INSTRUCTIONS:

       Inject an existing analytics tracker (or client), that is defined outside of the Node, into the
       class defined in this file (below).

       Inject the tracker (or client) via a protocol. The protocol for the injected tracker (or client)
       can either be an existing one defined outside of the Node or can be a new one added to this file.
       */

      /**
       PURPOSE:
       The interface for analytics tracked by this Node.

       Add requirements to this protocol to provide analytics tracking methods for this Node.
       */
      internal protocol AppAnalytics: AnyObject {}

      /**
       PURPOSE:
       Custom analytics implementation for this Node.
       */
      internal final class AppAnalyticsImp {}

      extension AppAnalyticsImp: AppAnalytics {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/1 App/AppBuilder.swift"
    contents: |
      //
      //  AppBuilder.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import NeedleFoundation
      import Nodes

      /**
       PURPOSE:
       The interface of the Flow.
       */
      internal protocol AppFlow: Flow {}

      /**
       PURPOSE:
       A dependency needed by the Builder (such as a Listener), passed in from the caller (i.e. is not on the DI graph).

       Can be a tuple or struct containing multiple values when necessary.
       */
      internal typealias AppDynamicBuildDependency = Void

      /**
       PURPOSE:
       A dependency used by the Component itself, passed into the Component's initializer (in the Component factory).

       Can be a tuple or struct containing multiple values when necessary.
       */
      internal typealias AppDynamicComponentDependency = Void

      // MARK: - Component

      /**
       PURPOSE:
       Declares dependencies that are owned by this Node.
       */
      @MainActor
      internal final class AppComponent: BootstrapComponent {

          /*
           Dependencies
           ============

           Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

           fileprivate let example: Example = .init()

           Whenever possible, for example when the dependency does not provide shared state, define the property as a
           factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
           Needle compatibility whenever the access control is increased.

           fileprivate var exampleFactory: Example {
               Example()
           }

           When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
           that always returns the same instance from a computed property.

           fileprivate var example: Example {
               shared { Example(otherDependency: dependency.otherDependency) }
           }

           */

          fileprivate let appService: AppService = AppServiceImp()

          private let dynamicDependency: AppDynamicComponentDependency

          /// The initializer.
          ///
          /// Remove `dynamicDependency` default parameter when its type is not `Void`.
          ///
          /// - Parameter parent: The parent scope
          /// - Parameter dynamicDependency: The dynamic component dependency
          internal init(dynamicDependency: AppDynamicComponentDependency = ()) {
              self.dynamicDependency = dynamicDependency
              super.init()
          }

          /*
           Child Components
           ================

           Declare child component factories as 'fileprivate' methods.

           fileprivate func <name>ComponentFactory() -> <Name>Component {
               <Name>Component(parent: self)
           }

           */

          fileprivate func sceneComponentFactory() -> SceneComponent {
              SceneComponent(parent: self)
          }
      }

      // MARK: - Builder

      /**
       PURPOSE:
       The Builder interface (available to mock for testability).
       */
      @MainActor
      internal protocol AppBuilder: AnyObject {
          func build() -> AppFlow
      }

      /**
       PURPOSE:
       Concrete implementation of the Builder, where everything is created and associated.
       */
      internal final class AppBuilderImp: AbstractBuilder
      <
          AppComponent,
          AppFlow,
          AppDynamicBuildDependency,
          AppDynamicComponentDependency
      > {

          /// The purpose of this method is to route input parameters to either the dynamic build dependency and/or
          /// the dynamic component dependency.
          ///
          /// The dynamic dependencies can be tuples or structs containing multiple values when necessary.
          /// - Returns: The Flow instance
          internal func build() -> AppFlow {
              let dynamicBuildDependency: AppDynamicBuildDependency = ()
              let dynamicComponentDependency: AppDynamicComponentDependency = ()
              return build(dynamicBuildDependency, dynamicComponentDependency)
          }

          /// The factory method in which the Context and Flow are initialized.
          /// - Parameters:
          ///   - component: The component instance
          ///   - dynamicBuildDependency: The dynamic build dependency
          /// - Returns: The Flow instance
          override internal func build(
              component: AppComponent,
              dynamicBuildDependency: AppDynamicBuildDependency
          ) -> AppFlow {
              let analytics: AppAnalyticsImp = .init()
              let context: AppContextImp = .init(
                  workers: [],
                  analytics: analytics,
                  windowSceneState: component.appService.windowSceneState
              )
              let flow: AppFlowImp = .init(
                  context: context,
                  sceneBuilder: SceneBuilderImp(componentFactory: component.sceneComponentFactory)
              )
              context.flow = flow
              return flow
          }
      }

      extension AppBuilderImp: AppBuilder {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/1 App/AppContext.swift"
    contents: |
      //
      //  AppContext.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The interface that the Context will speak to the Flow through. Used to initiate navigation as
       an example.
       */
      @MainActor
      internal protocol AppFlowInterface: Flow {
          func attachScene(_ viewController: WindowSceneViewControllable)
          func detachScene(_ viewController: WindowSceneViewControllable)
      }

      /**
       PURPOSE:
       Contains the business logic of the Node. The lifecycle of the Node is bookended between the
       `didBecomeActive` and `willResignActive` methods.
       */
      internal final class AppContextImp: AbstractContext
      <
          AnyCancellable
      > {

          /// The Flow instance.
          internal weak var flow: AppFlowInterface?

          /// The Analytics instance.
          private let analytics: AppAnalytics

          private let windowSceneState: AnyPublisher<WindowSceneState, Never>

          /// The initializer.
          /// - Parameters:
          ///   - workers: The Worker instances
          ///   - analytics: The Analytics instance
          internal init(
              workers: [Worker],
              analytics: AppAnalytics,
              windowSceneState: AnyPublisher<WindowSceneState, Never>
          ) {
              self.analytics = analytics
              self.windowSceneState = windowSceneState
              super.init(workers: workers)
          }

          /// Implement logic to execute when the Context becomes active.
          override internal func didBecomeActive() {
              subscribe(to: windowSceneState)
          }

          /// Implement logic to execute when the Context will become inactive.
          override internal func willResignActive() {}

          private func subscribe(to windowSceneState: AnyPublisher<WindowSceneState, Never>) {
              windowSceneState
                  .filter(\.isAdded)
                  .map(\.windowScene)
                  .sink { [weak self] in self?.flow?.attachScene($0) }
                  .store(in: &cancellables)
              windowSceneState
                  .filter(\.isRemoved)
                  .map(\.windowScene)
                  .sink { [weak self] in self?.flow?.detachScene($0) }
                  .store(in: &cancellables)
          }
      }

      extension AppContextImp: AppContextInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/1 App/AppFlow.swift"
    contents: |
      //
      //  AppFlow.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /**
       PURPOSE:
       The interface that the Flow will speak to the Context through. Used for informing the Context of
       presentation lifecycle events, as an example.
       */
      internal protocol AppContextInterface: Context, SceneListener {}

      /**
       PURPOSE:
       Responsible for presenting views and starting child Flows, and should not contain business logic.
       */
      internal final class AppFlowImp: AbstractFlow
      <
          AppContextInterface,
          Void
      > {

          private let sceneBuilder: SceneBuilder

          /// The initializer.
          ///
          /// Inject Plugins or Builders into the Flow in order to create sub-Flows.
          /// - Parameter context: The Context instance
          internal init(
              context: AppContextInterface,
              sceneBuilder: SceneBuilder
          ) {
              self.sceneBuilder = sceneBuilder
              super.init(context: context, viewController: ())
          }

          /// Implement logic to execute when the Flow is started.
          override internal func didStart() {}
      }

      extension AppFlowImp: AppFlow {}
      extension AppFlowImp: AppFlowInterface {

          internal func attachScene(_ viewController: WindowSceneViewControllable) {
              let flow: SceneFlow = sceneBuilder.build(withListener: context,
                                                       viewController: viewController)
              attach(starting: flow)
          }

          internal func detachScene(_ viewController: WindowSceneViewControllable) {
              subFlows
                  .compactMap { $0 as? SceneFlow }
                  .filter { $0.getViewController() === viewController }
                  .forEach(detach)
          }
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/2 Scene/SceneAnalytics.swift"
    contents: |
      //
      //  SceneAnalytics.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /*
       INSTRUCTIONS:

       Inject an existing analytics tracker (or client), that is defined outside of the Node, into the
       class defined in this file (below).

       Inject the tracker (or client) via a protocol. The protocol for the injected tracker (or client)
       can either be an existing one defined outside of the Node or can be a new one added to this file.
       */

      /**
       PURPOSE:
       The interface for analytics tracked by this Node.

       Add requirements to this protocol to provide analytics tracking methods for this Node.
       */
      internal protocol SceneAnalytics: AnyObject {}

      /**
       PURPOSE:
       Custom analytics implementation for this Node.
       */
      internal final class SceneAnalyticsImp {}

      extension SceneAnalyticsImp: SceneAnalytics {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/2 Scene/SceneBuilder.swift"
    contents: |
      //
      //  SceneBuilder.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import NeedleFoundation
      import Nodes

      /**
       PURPOSE:
       The interface of the Flow.
       */
      @MainActor
      internal protocol SceneFlow: Flow {
          func getViewController() -> WindowSceneViewControllable
      }

      /**
       PURPOSE:
       Declares the dependencies required by this Node that will be injected (not created by this Node itself).
       */
      public protocol SceneDependency: Dependency {}

      /**
       PURPOSE:
       A dependency needed by the Builder (such as a Listener), passed in from the caller (i.e. is not on the DI graph).

       Can be a tuple or struct containing multiple values when necessary.
       */
      internal typealias SceneDynamicBuildDependency = (SceneListener, WindowSceneViewControllable)

      /**
       PURPOSE:
       A dependency used by the Component itself, passed into the Component's initializer (in the Component factory).

       Can be a tuple or struct containing multiple values when necessary.
       */
      internal typealias SceneDynamicComponentDependency = Void

      // MARK: - Component

      /**
       PURPOSE:
       Declares dependencies that are owned by this Node.
       */
      internal final class SceneComponent: Component
      <
          SceneDependency
      > {

          /*
           Dependencies
           ============

           Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

           fileprivate let example: Example = .init()

           Whenever possible, for example when the dependency does not provide shared state, define the property as a
           factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
           Needle compatibility whenever the access control is increased.

           fileprivate var exampleFactory: Example {
               Example()
           }

           When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
           that always returns the same instance from a computed property.

           fileprivate var example: Example {
               shared { Example(otherDependency: dependency.otherDependency) }
           }

           */

          private let dynamicDependency: SceneDynamicComponentDependency

          /// The initializer.
          ///
          /// Remove `dynamicDependency` default parameter when its type is not `Void`.
          ///
          /// - Parameter parent: The parent scope
          /// - Parameter dynamicDependency: The dynamic component dependency
          internal init(parent: Scope, dynamicDependency: SceneDynamicComponentDependency = ()) {
              self.dynamicDependency = dynamicDependency
              super.init(parent: parent)
          }

          /*
           Child Components
           ================

           Declare child component factories as 'fileprivate' methods.

           fileprivate func <name>ComponentFactory() -> <Name>Component {
               <Name>Component(parent: self)
           }

           */

          fileprivate func windowComponentFactory() -> WindowComponent {
              WindowComponent(parent: self)
          }
      }

      // MARK: - Builder

      /**
       PURPOSE:
       The Builder interface (available to mock for testability).
       */
      @MainActor
      internal protocol SceneBuilder: AnyObject {
          func build(
              withListener listener: SceneListener,
              viewController: WindowSceneViewControllable
          ) -> SceneFlow
      }

      /**
       PURPOSE:
       Concrete implementation of the Builder, where everything is created and associated.
       */
      internal final class SceneBuilderImp: AbstractBuilder
      <
          SceneComponent,
          SceneFlow,
          SceneDynamicBuildDependency,
          SceneDynamicComponentDependency
      > {

          /// The purpose of this method is to route input parameters to either the dynamic build dependency and/or
          /// the dynamic component dependency.
          ///
          /// The dynamic dependencies can be tuples or structs containing multiple values when necessary.
          /// - Parameters:
          ///   - listener: An object that can listen for signals from the Node
          ///   - viewController: The injected view controller
          /// - Returns: The Flow instance
          internal func build(
              withListener listener: SceneListener,
              viewController: WindowSceneViewControllable
          ) -> SceneFlow {
              let dynamicBuildDependency: SceneDynamicBuildDependency = (listener, viewController)
              let dynamicComponentDependency: SceneDynamicComponentDependency = ()
              return build(dynamicBuildDependency, dynamicComponentDependency)
          }

          /// The factory method in which the Context and Flow are initialized.
          /// - Parameters:
          ///   - component: The component instance
          ///   - dynamicBuildDependency: The dynamic build dependency
          /// - Returns: The Flow instance
          override internal func build(
              component: SceneComponent,
              dynamicBuildDependency: SceneDynamicBuildDependency
          ) -> SceneFlow {
              let listener: SceneListener = dynamicBuildDependency.0
              let viewController: WindowSceneViewControllable = dynamicBuildDependency.1
              let analytics: SceneAnalyticsImp = .init()
              let context: SceneContextImp = .init(
                  workers: [],
                  analytics: analytics
              )
              context.listener = listener
              let flow: SceneFlowImp = .init(
                  context: context,
                  viewController: viewController,
                  windowBuilder: WindowBuilderImp(componentFactory: component.windowComponentFactory)
              )
              context.flow = flow
              return flow
          }
      }

      extension SceneBuilderImp: SceneBuilder {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/2 Scene/SceneContext.swift"
    contents: |
      //
      //  SceneContext.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The Context delegates callbacks to its (external) Listener, typically the parent Context.
       */
      internal protocol SceneListener: AnyObject {}

      /**
       PURPOSE:
       The interface that the Context will speak to the Flow through. Used to initiate navigation as
       an example.
       */
      internal protocol SceneFlowInterface: Flow {}

      /**
       PURPOSE:
       Contains the business logic of the Node. The lifecycle of the Node is bookended between the
       `didBecomeActive` and `willResignActive` methods.
       */
      internal final class SceneContextImp: AbstractContext
      <
          AnyCancellable
      > {

          /// The Flow instance.
          internal weak var flow: SceneFlowInterface?

          /// The Listener instance.
          internal weak var listener: SceneListener?

          /// The Analytics instance.
          private let analytics: SceneAnalytics

          /// The initializer.
          /// - Parameters:
          ///   - workers: The Worker instances
          ///   - analytics: The Analytics instance
          internal init(
              workers: [Worker],
              analytics: SceneAnalytics
          ) {
              self.analytics = analytics
              super.init(workers: workers)
          }

          /// Implement logic to execute when the Context becomes active.
          override internal func didBecomeActive() {}

          /// Implement logic to execute when the Context will become inactive.
          override internal func willResignActive() {}
      }

      extension SceneContextImp: SceneContextInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/2 Scene/SceneFlow.swift"
    contents: |
      //
      //  SceneFlow.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /**
       PURPOSE:
       The interface that the Flow will speak to the Context through. Used for informing the Context of
       presentation lifecycle events, as an example.
       */
      internal protocol SceneContextInterface: Context, WindowListener {}

      /**
       PURPOSE:
       Responsible for presenting views and starting child Flows, and should not contain business logic.
       */
      internal final class SceneFlowImp: AbstractFlow
      <
          SceneContextInterface,
          WindowSceneViewControllable
      > {

          private let windowBuilder: WindowBuilder

          /// The initializer.
          ///
          /// Inject Plugins or Builders into the Flow in order to create sub-Flows.
          /// - Parameters:
          ///   - context: The Context instance
          ///   - viewController: The View Controller instance
          internal init(
              context: SceneContextInterface,
              viewController: WindowSceneViewControllable,
              windowBuilder: WindowBuilder
          ) {
              self.windowBuilder = windowBuilder
              super.init(context: context, viewController: viewController)
          }

          /// Implement logic to execute when the Flow is started.
          override internal func didStart() {
              attachWindow()
          }

          /// Provides the ``ViewControllable`` instance to the parent `Flow` for display or presentation.
          ///
          /// - Returns: The ``ViewControllable`` instance.
          internal func getViewController() -> WindowSceneViewControllable {
              viewController
          }

          private func attachWindow() {
              let flow: WindowFlow = windowBuilder.build(withListener: context,
                                                         viewController: viewController.makeWindow())
              attach(starting: flow)
          }
      }

      extension SceneFlowImp: SceneFlow {}
      extension SceneFlowImp: SceneFlowInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/3 Window/WindowAnalytics.swift"
    contents: |
      //
      //  WindowAnalytics.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /*
       INSTRUCTIONS:

       Inject an existing analytics tracker (or client), that is defined outside of the Node, into the
       class defined in this file (below).

       Inject the tracker (or client) via a protocol. The protocol for the injected tracker (or client)
       can either be an existing one defined outside of the Node or can be a new one added to this file.
       */

      /**
       PURPOSE:
       The interface for analytics tracked by this Node.

       Add requirements to this protocol to provide analytics tracking methods for this Node.
       */
      internal protocol WindowAnalytics: AnyObject {}

      /**
       PURPOSE:
       Custom analytics implementation for this Node.
       */
      internal final class WindowAnalyticsImp {}

      extension WindowAnalyticsImp: WindowAnalytics {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/3 Window/WindowBuilder.swift"
    contents: |
      //
      //  WindowBuilder.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import NeedleFoundation
      import Nodes

      /**
       PURPOSE:
       The interface of the Flow.
       */
      internal protocol WindowFlow: Flow {}

      /**
       PURPOSE:
       Declares the dependencies required by this Node that will be injected (not created by this Node itself).
       */
      public protocol WindowDependency: Dependency {}

      /**
       PURPOSE:
       A dependency needed by the Builder (such as a Listener), passed in from the caller (i.e. is not on the DI graph).

       Can be a tuple or struct containing multiple values when necessary.
       */
      internal typealias WindowDynamicBuildDependency = (WindowListener, WindowViewControllable)

      /**
       PURPOSE:
       A dependency used by the Component itself, passed into the Component's initializer (in the Component factory).

       Can be a tuple or struct containing multiple values when necessary.
       */
      internal typealias WindowDynamicComponentDependency = Void

      // MARK: - Component

      /**
       PURPOSE:
       Declares dependencies that are owned by this Node.
       */
      internal final class WindowComponent: Component
      <
          WindowDependency
      > {

          /*
           Dependencies
           ============

           Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

           fileprivate let example: Example = .init()

           Whenever possible, for example when the dependency does not provide shared state, define the property as a
           factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
           Needle compatibility whenever the access control is increased.

           fileprivate var exampleFactory: Example {
               Example()
           }

           When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
           that always returns the same instance from a computed property.

           fileprivate var example: Example {
               shared { Example(otherDependency: dependency.otherDependency) }
           }

           */

          private let dynamicDependency: WindowDynamicComponentDependency

          /// The initializer.
          ///
          /// Remove `dynamicDependency` default parameter when its type is not `Void`.
          ///
          /// - Parameter parent: The parent scope
          /// - Parameter dynamicDependency: The dynamic component dependency
          internal init(parent: Scope, dynamicDependency: WindowDynamicComponentDependency = ()) {
              self.dynamicDependency = dynamicDependency
              super.init(parent: parent)
          }

          /*
           Child Components
           ================

           Declare child component factories as 'fileprivate' methods.

           fileprivate func <name>ComponentFactory() -> <Name>Component {
               <Name>Component(parent: self)
           }

           */

          fileprivate func rootComponentFactory() -> RootComponent {
              RootComponent(parent: self)
          }
      }

      // MARK: - Builder

      /**
       PURPOSE:
       The Builder interface (available to mock for testability).
       */
      @MainActor
      internal protocol WindowBuilder: AnyObject {
          func build(
              withListener listener: WindowListener,
              viewController: WindowViewControllable
          ) -> WindowFlow
      }

      /**
       PURPOSE:
       Concrete implementation of the Builder, where everything is created and associated.
       */
      internal final class WindowBuilderImp: AbstractBuilder
      <
          WindowComponent,
          WindowFlow,
          WindowDynamicBuildDependency,
          WindowDynamicComponentDependency
      > {

          /// The purpose of this method is to route input parameters to either the dynamic build dependency and/or
          /// the dynamic component dependency.
          ///
          /// The dynamic dependencies can be tuples or structs containing multiple values when necessary.
          /// - Parameters:
          ///   - listener: An object that can listen for signals from the Node
          ///   - viewController: The injected view controller
          /// - Returns: The Flow instance
          internal func build(
              withListener listener: WindowListener,
              viewController: WindowViewControllable
          ) -> WindowFlow {
              let dynamicBuildDependency: WindowDynamicBuildDependency = (listener, viewController)
              let dynamicComponentDependency: WindowDynamicComponentDependency = ()
              return build(dynamicBuildDependency, dynamicComponentDependency)
          }

          /// The factory method in which the Context and Flow are initialized.
          /// - Parameters:
          ///   - component: The component instance
          ///   - dynamicBuildDependency: The dynamic build dependency
          /// - Returns: The Flow instance
          override internal func build(
              component: WindowComponent,
              dynamicBuildDependency: WindowDynamicBuildDependency
          ) -> WindowFlow {
              let listener: WindowListener = dynamicBuildDependency.0
              let viewController: WindowViewControllable = dynamicBuildDependency.1
              let analytics: WindowAnalyticsImp = .init()
              let context: WindowContextImp = .init(
                  workers: [],
                  analytics: analytics
              )
              context.listener = listener
              let flow: WindowFlowImp = .init(
                  context: context,
                  viewController: viewController,
                  rootBuilder: RootBuilderImp(componentFactory: component.rootComponentFactory)
              )
              context.flow = flow
              return flow
          }
      }

      extension WindowBuilderImp: WindowBuilder {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/3 Window/WindowContext.swift"
    contents: |
      //
      //  WindowContext.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The Context delegates callbacks to its (external) Listener, typically the parent Context.
       */
      internal protocol WindowListener: AnyObject {}

      /**
       PURPOSE:
       The interface that the Context will speak to the Flow through. Used to initiate navigation as
       an example.
       */
      internal protocol WindowFlowInterface: Flow {}

      /**
       PURPOSE:
       Contains the business logic of the Node. The lifecycle of the Node is bookended between the
       `didBecomeActive` and `willResignActive` methods.
       */
      internal final class WindowContextImp: AbstractContext
      <
          AnyCancellable
      > {

          /// The Flow instance.
          internal weak var flow: WindowFlowInterface?

          /// The Listener instance.
          internal weak var listener: WindowListener?

          /// The Analytics instance.
          private let analytics: WindowAnalytics

          /// The initializer.
          /// - Parameters:
          ///   - workers: The Worker instances
          ///   - analytics: The Analytics instance
          internal init(
              workers: [Worker],
              analytics: WindowAnalytics
          ) {
              self.analytics = analytics
              super.init(workers: workers)
          }

          /// Implement logic to execute when the Context becomes active.
          override internal func didBecomeActive() {}

          /// Implement logic to execute when the Context will become inactive.
          override internal func willResignActive() {}
      }

      extension WindowContextImp: WindowContextInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/3 Window/WindowFlow.swift"
    contents: |
      //
      //  WindowFlow.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /**
       PURPOSE:
       The interface that the Flow will speak to the Context through. Used for informing the Context of
       presentation lifecycle events, as an example.
       */
      internal protocol WindowContextInterface: Context, RootListener {}

      /**
       PURPOSE:
       Responsible for presenting views and starting child Flows, and should not contain business logic.
       */
      internal final class WindowFlowImp: AbstractFlow
      <
          WindowContextInterface,
          WindowViewControllable
      > {

          private let rootBuilder: RootBuilder

          /// The initializer.
          ///
          /// Inject Plugins or Builders into the Flow in order to create sub-Flows.
          /// - Parameters:
          ///   - context: The Context instance
          ///   - viewController: The View Controller instance
          internal init(
              context: WindowContextInterface,
              viewController: WindowViewControllable,
              rootBuilder: RootBuilder
          ) {
              self.rootBuilder = rootBuilder
              super.init(context: context, viewController: viewController)
          }

          /// Implement logic to execute when the Flow is started.
          override internal func didStart() {
              attachRoot()
          }

          private func attachRoot() {
              let flow: RootFlow = rootBuilder.build(withListener: context)
              viewController.present(flow.getViewController())
              attach(starting: flow)
          }
      }

      extension WindowFlowImp: WindowFlow {}
      extension WindowFlowImp: WindowFlowInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootAnalytics.swift"
    contents: |
      //
      //  RootAnalytics.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /*
       INSTRUCTIONS:

       Inject an existing analytics tracker (or client), that is defined outside of the Node, into the
       class defined in this file (below).

       Inject the tracker (or client) via a protocol. The protocol for the injected tracker (or client)
       can either be an existing one defined outside of the Node or can be a new one added to this file.
       */

      /**
       PURPOSE:
       The interface for analytics tracked by this Node.

       Add requirements to this protocol to provide analytics tracking methods for this Node.
       */
      internal protocol RootAnalytics: AnyObject {}

      /**
       PURPOSE:
       Custom analytics implementation for this Node.
       */
      internal final class RootAnalyticsImp {}

      extension RootAnalyticsImp: RootAnalytics {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootBuilder.swift"
    contents: |
      //
      //  RootBuilder.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import NeedleFoundation
      import Nodes

      /**
       PURPOSE:
       The interface of the Flow.
       */
      internal protocol RootFlow: ViewControllableFlow {}

      /**
       PURPOSE:
       Declares the dependencies required by this Node that will be injected (not created by this Node itself).
       */
      public protocol RootDependency: Dependency {}

      /**
       PURPOSE:
       A dependency needed by the Builder (such as a Listener), passed in from the caller (i.e. is not on the DI graph).

       Can be a tuple or struct containing multiple values when necessary.
       */
      internal typealias RootDynamicBuildDependency = RootListener

      /**
       PURPOSE:
       A dependency used by the Component itself, passed into the Component's initializer (in the Component factory).

       Can be a tuple or struct containing multiple values when necessary.
       */
      internal typealias RootDynamicComponentDependency = Void

      // MARK: - Component

      /**
       PURPOSE:
       Declares dependencies that are owned by this Node.
       */
      internal final class RootComponent: Component
      <
          RootDependency
      > {

          /*
           Dependencies
           ============

           Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

           fileprivate let example: Example = .init()

           Whenever possible, for example when the dependency does not provide shared state, define the property as a
           factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
           Needle compatibility whenever the access control is increased.

           fileprivate var exampleFactory: Example {
               Example()
           }

           When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
           that always returns the same instance from a computed property.

           fileprivate var example: Example {
               shared { Example(otherDependency: dependency.otherDependency) }
           }

           */

          private let dynamicDependency: RootDynamicComponentDependency

          /// The initializer.
          ///
          /// Remove `dynamicDependency` default parameter when its type is not `Void`.
          ///
          /// - Parameter parent: The parent scope
          /// - Parameter dynamicDependency: The dynamic component dependency
          internal init(parent: Scope, dynamicDependency: RootDynamicComponentDependency = ()) {
              self.dynamicDependency = dynamicDependency
              super.init(parent: parent)
          }

          /*
           Child Components
           ================

           Declare child component factories as 'fileprivate' methods.

           fileprivate func <name>ComponentFactory() -> <Name>Component {
               <Name>Component(parent: self)
           }

           */
      }

      // MARK: - Builder

      /**
       PURPOSE:
       The Builder interface (available to mock for testability).
       */
      @MainActor
      internal protocol RootBuilder: AnyObject {
          func build(
              withListener listener: RootListener
          ) -> RootFlow
      }

      /**
       PURPOSE:
       Concrete implementation of the Builder, where everything is created and associated.
       */
      internal final class RootBuilderImp: AbstractBuilder
      <
          RootComponent,
          RootFlow,
          RootDynamicBuildDependency,
          RootDynamicComponentDependency
      > {

          /// The purpose of this method is to route input parameters to either the dynamic build dependency and/or
          /// the dynamic component dependency.
          ///
          /// The dynamic dependencies can be tuples or structs containing multiple values when necessary.
          /// - Parameter listener: An object that can listen for signals from the Node
          /// - Returns: The Flow instance
          internal func build(
              withListener listener: RootListener
          ) -> RootFlow {
              let dynamicBuildDependency: RootDynamicBuildDependency = listener
              let dynamicComponentDependency: RootDynamicComponentDependency = ()
              return build(dynamicBuildDependency, dynamicComponentDependency)
          }

          /// The factory method in which the Context and Flow are initialized.
          /// - Parameters:
          ///   - component: The component instance
          ///   - dynamicBuildDependency: The dynamic build dependency
          /// - Returns: The Flow instance
          override internal func build(
              component: RootComponent,
              dynamicBuildDependency: RootDynamicBuildDependency
          ) -> RootFlow {
              let listener: RootListener = dynamicBuildDependency
              let analytics: RootAnalyticsImp = .init()
              let context: RootContextImp = .init(
                  workers: [],
                  analytics: analytics
              )
              context.listener = listener
              let viewStateFactory: RootViewStateFactory = .init()
              let viewState: Publishers.Map = .init(
                  upstream: context.$state,
                  transform: viewStateFactory
              )
              let viewController: RootViewController = .init(
                  initialState: viewStateFactory(context.state),
                  statePublisher: viewState.eraseToAnyPublisher()
              )
              viewController.receiver = context
              let flow: RootFlowImp = .init(
                  context: context,
                  viewController: viewController
              )
              context.flow = flow
              return flow
          }
      }

      extension RootBuilderImp: RootBuilder {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootContext.swift"
    contents: |
      //
      //  RootContext.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The Context delegates callbacks to its (external) Listener, typically the parent Context.
       */
      internal protocol RootListener: AnyObject {}

      /**
       PURPOSE:
       The interface that the Context will speak to the Flow through. Used to initiate navigation as
       an example.
       */
      @MainActor
      internal protocol RootFlowInterface: Flow {
          func didBecomeReady()
      }

      /**
       PURPOSE:
       Contains the business logic of the Node. The lifecycle of the Node is bookended between the
       `didBecomeActive` and `willResignActive` methods.
       */
      internal final class RootContextImp: AbstractContext
      <
          AnyCancellable
      > {

          /// The Flow instance.
          internal weak var flow: RootFlowInterface?

          /// The Listener instance.
          internal weak var listener: RootListener?

          /// The State instance.
          @Published internal private(set) var state: RootState

          /// The Analytics instance.
          private let analytics: RootAnalytics

          // swiftlint:disable:next redundant_type_annotation
          private var isReady: Bool = false

          /// The initializer.
          /// - Parameters:
          ///   - workers: The Worker instances
          ///   - analytics: The Analytics instance
          internal init(
              workers: [Worker],
              analytics: RootAnalytics
          ) {
              self.state = RootState(name: "{{ project }}")
              self.analytics = analytics
              super.init(workers: workers)
          }

          /// Implement logic to execute when the Context becomes active.
          override internal func didBecomeActive() {}

          /// Implement logic to execute when the Context will become inactive.
          override internal func willResignActive() {}
      }

      extension RootContextImp: RootContextInterface {}
      extension RootContextImp: RootReceiver {

          internal func viewDidAppear() {
              guard !isReady
              else { return }
              isReady = true
              flow?.didBecomeReady()
          }
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootFlow.swift"
    contents: |
      //
      //  RootFlow.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /**
       PURPOSE:
       The interface that the Flow will speak to the Context through. Used for informing the Context of
       presentation lifecycle events, as an example.
       */
      internal protocol RootContextInterface: Context {}

      /**
       PURPOSE:
       The interface of the View used for presenting the View of child Nodes. May inherit additional base
       protocols to add further pre-baked presentation behavior and/or add new methods for custom presentation
       implementation as necessary.
       */
      internal protocol RootViewControllable: ViewControllable {}

      /**
       PURPOSE:
       Responsible for presenting views and starting child Flows, and should not contain business logic.
       */
      internal final class RootFlowImp: AbstractFlow
      <
          RootContextInterface,
          RootViewControllable
      > {

          /// The initializer.
          ///
          /// Inject Plugins or Builders into the Flow in order to create sub-Flows.
          /// - Parameters:
          ///   - context: The Context instance
          ///   - viewController: The View Controller instance
          override internal init(
              context: RootContextInterface,
              viewController: RootViewControllable
          ) {
              super.init(context: context, viewController: viewController)
          }

          /// Implement logic to execute when the Flow is started.
          override internal func didStart() {}

          /// Provides the ``ViewControllable`` instance to the parent `Flow` for display or presentation.
          ///
          /// - Returns: The ``ViewControllable`` instance.
          internal func getViewController() -> ViewControllable {
              viewController
          }
      }

      extension RootFlowImp: RootFlow {}
      extension RootFlowImp: RootFlowInterface {

          /// Implement logic to execute when the Root Flow is ready to attach child Flows.
          internal func didBecomeReady() {}
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootState.swift"
    contents: |
      //
      //  RootState.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /**
       PURPOSE:
       The state of the Node.
       */
      internal struct RootState: Equatable {

          internal var name: String
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootViewController.swift"
    contents: |
      //
      //  RootViewController.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes
      import UIKit

      /**
       PURPOSE:
       The interface that the View will speak to the Context through. Used for informing the Context of
       view events and user interactions.
       */
      @MainActor
      internal protocol RootReceiver: AnyObject {
          func viewDidAppear()
      }

      /**
       PURPOSE:
       Concrete implementation of the UI.
       */
      internal final class RootViewController: UIViewController, StateObserver {

          /// The view receiver.
          internal weak var receiver: RootReceiver?

          /// The collection of cancellable instances.
          private var cancellables: Set<AnyCancellable> = .init()

          /// The initial view state.
          private let initialState: RootViewState

          /// The view state publisher.
          private let statePublisher: AnyPublisher<RootViewState, Never>

          private let label: UILabel = .init()

          /// The initializer.
          ///
          /// - Parameters:
          ///   - initialState: The initial view state.
          ///   - statePublisher: The view state publisher.
          internal init(
              initialState: RootViewState,
              statePublisher: AnyPublisher<RootViewState, Never>
          ) {
              self.initialState = initialState
              self.statePublisher = statePublisher
                  .removeDuplicates()
                  .receive(on: DispatchQueue.main)
                  .eraseToAnyPublisher()
              super.init(nibName: nil, bundle: nil)
          }

          @available(*, unavailable)
          internal required init?(coder: NSCoder) {
              preconditionFailure("init(coder:) has not been implemented")
          }

          override internal func viewDidLoad() {
              super.viewDidLoad()
              view.backgroundColor = .systemBackground
              label.translatesAutoresizingMaskIntoConstraints = false
              view.addSubview(label)
              view.addConstraints([
                  label.centerXAnchor.constraint(equalTo: view.centerXAnchor),
                  label.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: -20)
              ])
              update(with: initialState)
          }

          override internal func viewWillAppear(_ animated: Bool) {
              super.viewWillAppear(animated)
              observe(statePublisher).store(in: &cancellables)
          }

          override internal func viewDidAppear(_ animated: Bool) {
              super.viewDidAppear(animated)
              receiver?.viewDidAppear()
          }

          override internal func viewWillDisappear(_ animated: Bool) {
              super.viewWillDisappear(animated)
              cancellables.removeAll()
          }

          internal func update(with viewState: RootViewState) {
              // Add implementation to update the user interface when the view state changes.
              label.text = viewState.title
          }
      }

      extension RootViewController: RootViewControllable {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootViewState.swift"
    contents: |
      //
      //  RootViewState.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Nodes

      /**
       PURPOSE:
       The view state of the view.
       */
      internal struct RootViewState: Equatable {

          internal let title: String
      }

      /**
       PURPOSE:
       The factory used to create view state from the state of the Node.
       */
      internal class RootViewStateFactory: Nodes.Transform {

          /// The factory method in which state is transformed into view state.
          ///
          /// - Parameter state: The state.
          /// - Returns: The view state.
          internal func callAsFunction(_ state: RootState) -> RootViewState {
              RootViewState(title: state.name)
          }
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/Services/AppService.swift"
    contents: |
      //
      //  AppService.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import UIKit

      /// @mockable
      @MainActor
      internal protocol AppService {
          var windowSceneState: AnyPublisher<WindowSceneState, Never> { get }
      }

      internal final class AppServiceImp: AppService {

          internal var windowSceneState: AnyPublisher<WindowSceneState, Never> {
              Publishers.Merge(
                  notificationCenter
                      .publisher(for: UIScene.willConnectNotification)
                      .compactMap { $0.object as? UIWindowScene }
                      .map { .added($0) },
                  notificationCenter
                      .publisher(for: UIScene.didDisconnectNotification)
                      .compactMap { $0.object as? UIWindowScene }
                      .map { .removed($0) })
              .eraseToAnyPublisher()
          }

          private let notificationCenter: NotificationCenter

          internal init(notificationCenter: NotificationCenter = Foundation.NotificationCenter.default) {
              self.notificationCenter = notificationCenter
          }
      }

      internal enum WindowSceneState {

          case added(UIWindowScene)
          case removed(UIWindowScene)

          internal var isAdded: Bool {
              guard case .added = self
              else { return false }
              return true
          }

          internal var isRemoved: Bool {
              guard case .removed = self
              else { return false }
              return true
          }

          internal var windowScene: UIWindowScene {
              switch self {
              case let .added(windowScene):
                  return windowScene
              case let .removed(windowScene):
                  return windowScene
              }
          }
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/System/NotificationCenter.swift"
    contents: |
      //
      //  NotificationCenter.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Foundation

      /// @mockable(module: prefix = {{ project|split:' '|join:'_' }})
      internal protocol NotificationCenter {
          func publisher(for name: Notification.Name, object: AnyObject?) -> Foundation.NotificationCenter.Publisher
      }

      extension NotificationCenter {

          internal func publisher(for name: Notification.Name) -> Foundation.NotificationCenter.Publisher {
              publisher(for: name, object: nil)
          }
      }

      extension Foundation.NotificationCenter: NotificationCenter {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/Utility/AnyCancellable+Cancellable.swift"
    contents: |
      //
      //  AnyCancellable+Cancellable.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      extension Combine.AnyCancellable: Nodes.Cancellable {}

  - path: "{{ project|split:' '|join:'_' }}Tests/.swiftlint.yml"
    contents: |
      disabled_rules:
      - explicit_acl
      - explicit_top_level_acl
      - file_length
      - force_cast
      - force_try
      - force_unwrapping
      - function_body_length
      - implicitly_unwrapped_optional
      - type_body_length
      - weak_delegate

  - path: "{{ project|split:' '|join:'_' }}Tests/BuildSettings/Debug.xcconfig"
    contents: |
      #include "Shared.xcconfig"

  - path: "{{ project|split:' '|join:'_' }}Tests/BuildSettings/Release.xcconfig"
    contents: |
      #include "Shared.xcconfig"

  - path: "{{ project|split:' '|join:'_' }}Tests/BuildSettings/Shared.xcconfig"
    contents: |
      ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES
      BUNDLE_LOADER = $(TEST_HOST)
      CODE_SIGN_STYLE = Automatic
      LD_RUNPATH_SEARCH_PATHS = $(inherited) @executable_path/Frameworks @loader_path/Frameworks
      PRODUCT_NAME = $(TARGET_NAME)
      SWIFT_VERSION = 5.0
      TARGETED_DEVICE_FAMILY = 1,2
      TEST_HOST = $(BUILT_PRODUCTS_DIR)/{{ project|split:' '|join:'_' }}.app/{{ project|split:' '|join:'_' }}

  - path: "{{ project|split:' '|join:'_' }}Tests/Generated/.gitignore"
    contents: |
      *
      !.gitignore

  - path: "{{ project|split:' '|join:'_' }}Tests/Tests/{{ project|split:' '|join:'_' }}Tests.swift"
    contents: |
      //
      //  {{ project|split:' '|join:'_' }}Tests.swift
      //  {{ project|split:' '|join:'_' }}Tests
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import XCTest

      final class {{ project|split:' '|join:'_' }}Tests: XCTestCase {}


  - path: Makefile
    contents: ".PHONY: open\nopen:\n\txcodegen\n"

  - path: Package.swift
    contents: |
      // swift-tools-version:5.8

      import PackageDescription

      let package = Package(
          name: "{{ project|split:' '|join:'_' }}",
          products: [],
          dependencies: [
              .package(
                  url: "git@github.com:TinderApp/Nodes.git",
                  from: "{{ nodes }}"),
          ],
          targets: [
              .binaryTarget(
                  name: "SwiftLintBinary-Investigations",
                  url: "https://github.com/realm/SwiftLint/releases/download/0.52.4/SwiftLintBinary-macos.artifactbundle.zip",
                  checksum: "8a8095e6235a07d00f34a9e500e7568b359f6f66a249f36d12cd846017a8c6f5"),
          ]
      )

  - path: project.yml
    contents: |
      name: {{ project|split:' '|join:'_' }}
      options:
        bundleIdPrefix: {{ prefix }}
        deploymentTarget:
          iOS: "15.0"
        defaultConfig: Release
        settingPresets: none
        usesTabs: false
        tabWidth: 4
        indentWidth: 4
        preGenCommand: |
          set -e
          if test -z "$CI"
          then
              WORKSPACE_DOCUMENT_NAME="{{ project|split:' '|join:'_' }}.xcodeproj"
              osascript \
                  -e 'set workspaceDocumentName to "'"${WORKSPACE_DOCUMENT_NAME}"'"' \
                  -e 'if app id "com.apple.dt.Xcode" is running then' \
                  -e 'tell app id "com.apple.dt.Xcode"' \
                  -e 'if workspace document workspaceDocumentName exists then' \
                  -e 'set workspaceDocument to workspace document workspaceDocumentName' \
                  -e 'if loaded of workspaceDocument is false then' \
                  -e 'error "workspace not loaded"' \
                  -e 'end if' \
                  -e 'log "⚙️  Closing project..."' \
                  -e 'tell workspaceDocument' \
                  -e 'stop it' \
                  -e 'delay 0.5' \
                  -e 'close it' \
                  -e 'end tell' \
                  -e 'activate' \
                  -e 'delay 1.5' \
                  -e 'end if' \
                  -e 'end tell' \
                  -e 'end if'
              unset WORKSPACE_DOCUMENT_NAME
          fi
          NEEDLE_GENERATED="{{ project|split:' '|join:'_' }}/Generated/NeedleGenerated.swift"
          MOCKOLO_GENERATED="{{ project|split:' '|join:'_' }}Tests/Generated/MockoloGenerated.swift"
          [[ -f "${NEEDLE_GENERATED}" ]] || touch "${NEEDLE_GENERATED}"
          [[ -f "${MOCKOLO_GENERATED}" ]] || touch "${MOCKOLO_GENERATED}"
          unset NEEDLE_GENERATED MOCKOLO_GENERATED
        postGenCommand: |
          set -e
          if test -z "$CI"
          then
              swift run -- nodes-xcode-templates-gen --id "Xcode Templates"
              xed {{ project|split:' '|join:'_' }}.xcodeproj
          fi
      packages:
        Nodes:
          url: git@github.com:TinderApp/Nodes.git
          from: {{ nodes }}
        NeedleFoundation:
          url: https://github.com/uber/needle.git
          from: 0.18.0
      configFiles:
        Debug: BuildSettings/Debug.xcconfig
        Release: BuildSettings/Release.xcconfig
      fileGroups:
        - BuildSettings
      targets:
        {{ project|split:' '|join:'_' }}:
          type: application
          platform: iOS
          dependencies:
            - package: Nodes
              product: Nodes
            - package: NeedleFoundation
          preBuildScripts:
            - name: SwiftLint
              basedOnDependencyAnalysis: false
              script: |
                # Ignore Bazel environment variable (if set)
                # https://bazel.build/docs/user-manual#running-executables
                # https://github.com/realm/SwiftLint/blob/0.52.4/Source/swiftlint/Commands/SwiftLint.swift#L8
                unset BUILD_WORKSPACE_DIRECTORY

                DIRECTORY_NAME=$(echo "${PWD##*/}" | tr '[:upper:]' '[:lower:]')

                "$(find ".build/artifacts/${DIRECTORY_NAME}" -type f -name swiftlint -perm +111 -print -quit)"
            - name: Needle
              basedOnDependencyAnalysis: false
              script: >
                env SOURCEKIT_LOGGING=0
                needle generate {{ project|split:' '|join:'_' }}/Generated/NeedleGenerated.swift
                {{ project|split:' '|join:'_' }}/Sources
          sources: {{ project|split:' '|join:'_' }}
          scheme:
            testTargets:
              - {{ project|split:' '|join:'_' }}Tests
          configFiles:
            Debug: {{ project|split:' '|join:'_' }}/BuildSettings/Debug.xcconfig
            Release: {{ project|split:' '|join:'_' }}/BuildSettings/Release.xcconfig
          info:
            path: {{ project|split:' '|join:'_' }}/Generated/Info.plist
            properties:
              CFBundleDevelopmentRegion: $(DEVELOPMENT_LANGUAGE)
              CFBundleDisplayName: {{ project|split:' '|join:'_' }}
              CFBundleExecutable: $(EXECUTABLE_NAME)
              CFBundleIdentifier: $(PRODUCT_BUNDLE_IDENTIFIER)
              CFBundleInfoDictionaryVersion: "6.0"
              CFBundleName: $(PRODUCT_NAME)
              CFBundlePackageType: $(PRODUCT_BUNDLE_PACKAGE_TYPE)
              CFBundleShortVersionString: "1.0"
              CFBundleVersion: "1"
              LSRequiresIPhoneOS: true
              UIApplicationSceneManifest:
                UIApplicationSupportsMultipleScenes: true
                UISceneConfigurations:
                  UIWindowSceneSessionRoleApplication:
                    - UISceneConfigurationName: Default Configuration
                      UISceneDelegateClassName: $(PRODUCT_MODULE_NAME).SceneDelegate
              UIApplicationSupportsIndirectInputEvents: true
              UILaunchStoryboardName: LaunchScreen
              UIRequiredDeviceCapabilities:
                - armv7
              UISupportedInterfaceOrientations:
                - UIInterfaceOrientationPortrait
                - UIInterfaceOrientationLandscapeLeft
                - UIInterfaceOrientationLandscapeRight
              UISupportedInterfaceOrientations~ipad:
                - UIInterfaceOrientationPortrait
                - UIInterfaceOrientationPortraitUpsideDown
                - UIInterfaceOrientationLandscapeLeft
                - UIInterfaceOrientationLandscapeRight
        {{ project|split:' '|join:'_' }}Tests:
          type: bundle.unit-test
          platform: iOS
          dependencies:
            - target: {{ project|split:' '|join:'_' }}
            - package: Nodes
              product: NodesTesting
          preBuildScripts:
            - name: Mockolo
              basedOnDependencyAnalysis: false
              script: >
                mockolo
                -d {{ project|split:' '|join:'_' }}Tests/Generated/MockoloGenerated.swift
                -i {{ project|split:' '|join:'_' }}
                -s {{ project|split:' '|join:'_' }}/Sources
                -s ${BUILD_DIR%Build/*}/SourcePackages/checkouts/Nodes/Sources/Nodes
                --custom-imports Nodes
          sources: {{ project|split:' '|join:'_' }}Tests
          configFiles:
            Debug: {{ project|split:' '|join:'_' }}Tests/BuildSettings/Debug.xcconfig
            Release: {{ project|split:' '|join:'_' }}Tests/BuildSettings/Release.xcconfig
          info:
            path: {{ project|split:' '|join:'_' }}Tests/Generated/Info.plist
            properties:
              CFBundleDevelopmentRegion: $(DEVELOPMENT_LANGUAGE)
              CFBundleExecutable: $(EXECUTABLE_NAME)
              CFBundleIdentifier: $(PRODUCT_BUNDLE_IDENTIFIER)
              CFBundleInfoDictionaryVersion: "6.0"
              CFBundleName: $(PRODUCT_NAME)
              CFBundlePackageType: $(PRODUCT_BUNDLE_PACKAGE_TYPE)
              CFBundleShortVersionString: "1.0"
              CFBundleVersion: "1"

  - path: README.md
    contents: |
      # {{ project }}

      ## Project Setup

      ### Install dependencies

      ```
      brew install xcodegen needle mockolo
      ```

      ### Generate Xcode project

      ```
      xcodegen
      ```

      Execute the `xcodegen` command any time the `project.yml` file is changed or project files are added or removed. See the [xcodegen](https://github.com/yonaskolb/XcodeGen) documentation for more information.
