options:

  - question: "Project Name:"
    name: project
    type: string
    required: true

  - question: "Organization Identifier (the bundle ID prefix):"
    name: prefix
    type: string
    required: true

  - question: "Author Name (for source file attribution):"
    name: author
    type: string
    required: true

  - question: "Today's Date (for source file attribution):"
    name: date
    type: string
    required: true

files:

  - path: .gitignore
    contents: |
      # macOS
      .DS_Store

      # SPM
      .swiftpm/
      .build/
      Packages/

      # Xcode
      *.xcworkspace/
      *.xcodeproj/

  - path: BuildSettings/Debug.xcconfig
    contents: |
      #include "Shared.xcconfig"

      DEBUG_INFORMATION_FORMAT = dwarf
      ENABLE_TESTABILITY = YES
      GCC_DYNAMIC_NO_PIC = NO
      GCC_OPTIMIZATION_LEVEL = 0
      GCC_PREPROCESSOR_DEFINITIONS = DEBUG=1
      MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE
      ONLY_ACTIVE_ARCH = YES
      SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG
      SWIFT_OPTIMIZATION_LEVEL = -Onone

  - path: BuildSettings/Release.xcconfig
    contents: |
      #include "Shared.xcconfig"

      DEBUG_INFORMATION_FORMAT = dwarf-with-dsym
      ENABLE_NS_ASSERTIONS = NO
      MTL_ENABLE_DEBUG_INFO = NO
      SWIFT_COMPILATION_MODE = wholemodule
      SWIFT_OPTIMIZATION_LEVEL = -O
      VALIDATE_PRODUCT = YES

  - path: BuildSettings/Shared.xcconfig
    contents: |
      ALWAYS_SEARCH_USER_PATHS = NO
      CLANG_ANALYZER_NONNULL = YES
      CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE
      CLANG_CXX_LANGUAGE_STANDARD = gnu++14
      CLANG_CXX_LIBRARY = libc++
      CLANG_ENABLE_MODULES = YES
      CLANG_ENABLE_OBJC_ARC = YES
      CLANG_ENABLE_OBJC_WEAK = YES
      CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
      CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES
      CLANG_WARN_BOOL_CONVERSION = YES
      CLANG_WARN_COMMA = YES
      CLANG_WARN_CONSTANT_CONVERSION = YES
      CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES
      CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR
      CLANG_WARN_DOCUMENTATION_COMMENTS = YES
      CLANG_WARN_EMPTY_BODY = YES
      CLANG_WARN_ENUM_CONVERSION = YES
      CLANG_WARN_INFINITE_RECURSION = YES
      CLANG_WARN_INT_CONVERSION = YES
      CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES
      CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
      CLANG_WARN_OBJC_LITERAL_CONVERSION = YES
      CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR
      CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES
      CLANG_WARN_RANGE_LOOP_ANALYSIS = YES
      CLANG_WARN_STRICT_PROTOTYPES = YES
      CLANG_WARN_SUSPICIOUS_MOVE = YES
      CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
      CLANG_WARN_UNREACHABLE_CODE = YES
      COPY_PHASE_STRIP = NO
      ENABLE_STRICT_OBJC_MSGSEND = YES
      GCC_C_LANGUAGE_STANDARD = gnu11
      GCC_NO_COMMON_BLOCKS = YES
      GCC_WARN_64_TO_32_BIT_CONVERSION = YES
      GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR
      GCC_WARN_UNDECLARED_SELECTOR = YES
      GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE
      GCC_WARN_UNUSED_FUNCTION = YES
      GCC_WARN_UNUSED_VARIABLE = YES
      MTL_FAST_MATH = YES
      SDKROOT = iphoneos

  - path: "{{ project|split:' '|join:'_' }}/Assets/Assets.xcassets/AccentColor.colorset/Contents.json"
    contents: |
      {
        "colors" : [
          {
            "idiom" : "universal"
          }
        ],
        "info" : {
          "author" : "xcode",
          "version" : 1
        }
      }

  - path: "{{ project|split:' '|join:'_' }}/Assets/Assets.xcassets/AppIcon.appiconset/Contents.json"
    contents: |
      {
        "images" : [
          {
            "idiom" : "iphone",
            "scale" : "2x",
            "size" : "20x20"
          },
          {
            "idiom" : "iphone",
            "scale" : "3x",
            "size" : "20x20"
          },
          {
            "idiom" : "iphone",
            "scale" : "2x",
            "size" : "29x29"
          },
          {
            "idiom" : "iphone",
            "scale" : "3x",
            "size" : "29x29"
          },
          {
            "idiom" : "iphone",
            "scale" : "2x",
            "size" : "40x40"
          },
          {
            "idiom" : "iphone",
            "scale" : "3x",
            "size" : "40x40"
          },
          {
            "idiom" : "iphone",
            "scale" : "2x",
            "size" : "60x60"
          },
          {
            "idiom" : "iphone",
            "scale" : "3x",
            "size" : "60x60"
          },
          {
            "idiom" : "ipad",
            "scale" : "1x",
            "size" : "20x20"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "20x20"
          },
          {
            "idiom" : "ipad",
            "scale" : "1x",
            "size" : "29x29"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "29x29"
          },
          {
            "idiom" : "ipad",
            "scale" : "1x",
            "size" : "40x40"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "40x40"
          },
          {
            "idiom" : "ipad",
            "scale" : "1x",
            "size" : "76x76"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "76x76"
          },
          {
            "idiom" : "ipad",
            "scale" : "2x",
            "size" : "83.5x83.5"
          },
          {
            "idiom" : "ios-marketing",
            "scale" : "1x",
            "size" : "1024x1024"
          }
        ],
        "info" : {
          "author" : "xcode",
          "version" : 1
        }
      }

  - path: "{{ project|split:' '|join:'_' }}/Assets/Assets.xcassets/Contents.json"
    contents: |
      {
        "info" : {
          "author" : "xcode",
          "version" : 1
        }
      }

  - path: "{{ project|split:' '|join:'_' }}/BuildSettings/Debug.xcconfig"
    contents: |
      #include "Shared.xcconfig"

  - path: "{{ project|split:' '|join:'_' }}/BuildSettings/Release.xcconfig"
    contents: |
      #include "Shared.xcconfig"

  - path: "{{ project|split:' '|join:'_' }}/BuildSettings/Shared.xcconfig"
    contents: |
      ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon
      ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor
      CODE_SIGN_STYLE = Automatic
      LD_RUNPATH_SEARCH_PATHS = $(inherited) @executable_path/Frameworks
      PRODUCT_NAME = $(TARGET_NAME)
      SWIFT_VERSION = 5.0
      TARGETED_DEVICE_FAMILY = 1,2

  - path: "{{ project|split:' '|join:'_' }}/Generated/.gitignore"
    contents: |
      *
      !.gitignore

  - path: "{{ project|split:' '|join:'_' }}/Resources/Base.lproj/LaunchScreen.storyboard"
    contents: |
      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
      <document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13122.16" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
          <dependencies>
              <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13104.12"/>
              <capability name="Safe area layout guides" minToolsVersion="9.0"/>
              <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
          </dependencies>
          <scenes>
              <!--View Controller-->
              <scene sceneID="EHf-IW-A2E">
                  <objects>
                      <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                          <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                              <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                              <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                              <color key="backgroundColor" xcode11CocoaTouchSystemColor="systemBackgroundColor" cocoaTouchSystemColor="whiteColor"/>
                              <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                          </view>
                      </viewController>
                      <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
                  </objects>
                  <point key="canvasLocation" x="53" y="375"/>
              </scene>
          </scenes>
      </document>

  - path: "{{ project|split:' '|join:'_' }}/Sources/AppDelegate.swift"
    contents: |
      //
      //  AppDelegate.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import UIKit

      @main
      internal final class AppDelegate: UIResponder, UIApplicationDelegate {

          private lazy var appBuilder: AppBuilder = AppBuilderImp { AppComponent() }
          private lazy var appFlow: AppFlow = appBuilder.build()

          internal convenience init(appBuilder: AppBuilder) {
              self.init()
              self.appBuilder = appBuilder
          }

          internal func application(
              _ application: UIApplication,
              didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
          ) -> Bool {
              bootstrap()
              return true
          }

          private func bootstrap() {
              #if DEBUG
              guard appBuilder is AppBuilderImp
              else { return appFlow.start() }
              guard NSClassFromString("XCTestCase") == nil
              else { return }
              #endif
              registerProviderFactories()
              appFlow.start()
          }
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/SceneDelegate.swift"
    contents: |
      //
      //  SceneDelegate.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import UIKit

      internal final class SceneDelegate: UIResponder, UIWindowSceneDelegate {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/1 App/AppAnalytics.swift"
    contents: |
      //
      //  AppAnalytics.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /*
       INSTRUCTIONS:

       Option 1
       ========
       Conform an existing analytics tracker (or client), that is defined outside of the Node, to the
       AppAnalytics protocol.

       This option is preferred.

       When using this option, delete the class defined in this file (below).

       Option 2
       ========
       Inject an existing analytics tracker (or client), that is defined outside of the Node, into the
       class defined in this file (below).

       Only use this option if option 1 is not possible, for example, when the class defined in this
       file (below) is needed to store state (not recommended).

       When using this option, inject the tracker (or client) via a protocol. The protocol for the
       injected tracker (or client) can either be an existing one defined outside of the Node or
       can be a new one added to this file.
       */

      /**
       PURPOSE:
       The interface for analytics tracked by this Node.

       Whether using option 1 or 2, add requirements to this protocol to provide analytics tracking
       methods for this Node.
       */
      internal protocol AppAnalytics: AnyObject {}

      /**
       PURPOSE:
       The implementations of the protocol methods for analytics tracked by this Node.

       If using option 1, add implementations for the methods defined in the protocol that are not
       implemented by the conforming tracker (or client).

       If using option 2, delete this extension.
       */
      internal extension AppAnalytics {}

      /**
       PURPOSE:
       Custom analytics implementation for this Node, to be used ONLY when storing state is unavoidable.

       If using option 1, delete this class and extension below.
       */
      internal final class AppAnalyticsImp {}

      extension AppAnalyticsImp: AppAnalytics {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/1 App/AppBuilder.swift"
    contents: |
      //
      //  AppBuilder.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import NeedleFoundation
      import Nodes

      /**
       PURPOSE:
       The interface of the Flow.
       */
      internal protocol AppFlow: Flow {}

      /**
       PURPOSE:
       A dependency needed by the Builder (such as a Listener), passed in from the caller (i.e. is not on the DI graph).

       Can be a tuple containing multiple values when necessary.
       */
      internal typealias AppDynamicBuildDependency = Void

      /**
       PURPOSE:
       A dependency used by the Component itself, passed into the Component's initializer (in the Component factory).

       Can be a tuple containing multiple values when necessary.
       */
      internal typealias AppDynamicComponentDependency = Void

      // MARK: - Component

      /**
       PURPOSE:
       Declares dependencies that are owned by this Node.
       */
      internal final class AppComponent: BootstrapComponent {

          /*
           Dependencies
           ============

           Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

           fileprivate let example: Example = .init()

           Whenever possible, for example when the dependency does not provide shared state, define the property as a
           factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
           Needle compatibility whenever the access control is increased.

           fileprivate var exampleFactory: Example {
               Example()
           }

           When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
           that always returns the same instance from a computed property.

           fileprivate var example: Example {
               shared { Example(otherDependency: dependency.otherDependency) }
           }

           */

          fileprivate let appService: AppService = AppServiceImp()

          private let dynamicDependency: AppDynamicComponentDependency

          /// The initializer.
          ///
          /// Remove `dynamicDependency` default parameter when its type is not `Void`.
          ///
          /// - Parameter parent: The parent scope
          /// - Parameter dynamicDependency: The dynamic component dependency
          internal init(dynamicDependency: AppDynamicComponentDependency = ()) {
              self.dynamicDependency = dynamicDependency
              super.init()
          }

          /*
           Child Components
           ================

           Declare child component factories as 'fileprivate' methods.

           fileprivate func childComponentFactory() -> ChildComponent {
               ChildComponent(parent: self)
           }

           */

          fileprivate func sceneComponentFactory() -> SceneComponent {
              SceneComponent(parent: self)
          }
      }

      // MARK: - Builder

      /**
       PURPOSE:
       The Builder interface (available to mock for testability).
       */
      internal protocol AppBuilder: AnyObject {
          func build() -> AppFlow
      }

      internal typealias AppBuilderType = AbstractBuilder
          <
          AppComponent,
          AppFlow,
          AppDynamicBuildDependency,
          AppDynamicComponentDependency
          >

      /**
       PURPOSE:
       Concrete implementation of the Builder, where everything is created and associated.
       */
      internal final class AppBuilderImp: AppBuilderType {

          /// The purpose of this method is to route input parameters to either the dynamic build dependency and/or
          /// the dynamic component dependency.
          /// - Returns: The Flow instance
          internal func build() -> AppFlow {
              let dynamicBuildDependency: AppDynamicBuildDependency = ()
              let dynamicComponentDependency: AppDynamicComponentDependency = ()
              return build(dynamicBuildDependency, dynamicComponentDependency)
          }

          /// The factory method in which the Context and Flow are initialized.
          /// - Parameters:
          ///   - component: The component instance
          ///   - dynamicBuildDependency: The dynamic build dependency
          /// - Returns: The Flow instance
          override internal func build(
              component: AppComponent,
              dynamicBuildDependency: AppDynamicBuildDependency
          ) -> AppFlow {
              let analytics: AppAnalyticsImp = .init()
              let worker: AppWorkerImp = .init(
                  analytics: analytics
              )
              let context: AppContextImp = .init(
                  workers: [worker],
                  analytics: analytics,
                  windowSceneState: component.appService.windowSceneState
              )
              return AppFlowImp(context: context,
                                sceneBuilder: SceneBuilderImp(componentFactory: component.sceneComponentFactory))
          }
      }

      extension AppBuilderImp: AppBuilder {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/1 App/AppContext.swift"
    contents: |
      //
      //  AppContext.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The interface that the Context will speak to the Flow through. Used to initiate navigation as
       an example.
       */
      internal protocol AppFlowInterface: Flow {
          func attachScene(_ viewController: WindowSceneViewControllable)
          func detachScene(_ viewController: WindowSceneViewControllable)
      }

      /**
       PURPOSE:
       Contains the business logic of the Node. The lifecycle of the Node is bookended between the
       `didBecomeActive` and `willResignActive` methods.
       */
      internal final class AppContextImp: AbstractContext<AnyCancellable> {

          /// The Flow instance.
          internal weak var flow: AppFlowInterface?

          /// The Analytics instance.
          private let analytics: AppAnalytics

          private let windowSceneState: AnyPublisher<WindowSceneState, Never>

          /// The initializer.
          /// - Parameters:
          ///   - workers: The Worker instances
          ///   - analytics: The Analytics instance
          internal init(
              workers: [Worker],
              analytics: AppAnalytics,
              windowSceneState: AnyPublisher<WindowSceneState, Never>
          ) {
              self.analytics = analytics
              self.windowSceneState = windowSceneState
              super.init(workers: workers)
          }

          /// Implement logic to execute when the Context becomes active.
          override internal func didBecomeActive() {
              subscribe(to: windowSceneState)
          }

          /// Implement logic to execute when the Context will become inactive.
          override internal func willResignActive() {}

          deinit {
              LeakDetector.detect(analytics)
          }

          private func subscribe(to windowSceneState: AnyPublisher<WindowSceneState, Never>) {
              windowSceneState
                  .filter(\.isAdded)
                  .map(\.windowScene)
                  .sink { [weak self] in self?.flow?.attachScene($0) }
                  .store(in: &cancellables)
              windowSceneState
                  .filter(\.isRemoved)
                  .map(\.windowScene)
                  .sink { [weak self] in self?.flow?.detachScene($0) }
                  .store(in: &cancellables)
          }
      }

      extension AppContextImp: AppContextInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/1 App/AppFlow.swift"
    contents: |
      //
      //  AppFlow.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The interface that the Flow will speak to the Context through. Used for informing the Context of
       presentation lifecycle events, as an example.
       */
      internal protocol AppContextInterface: Context, SceneListener {
          var flow: AppFlowInterface? { get set }
      }

      /**
       PURPOSE:
       Responsible for presenting views and starting child Flows, and should not contain business logic.
       */
      internal final class AppFlowImp: AbstractFlow<AppContextInterface, Void> {

          private let sceneBuilder: SceneBuilder

          /// The initializer.
          ///
          /// Inject Plugins or Builders into the Flow in order to create sub-Flows.
          /// - Parameters:
          ///   - context: The Context instance
          internal init(
              context: AppContextInterface,
              sceneBuilder: SceneBuilder
          ) {
              self.sceneBuilder = sceneBuilder
              super.init(context: context, viewController: ())
              context.flow = self
          }

          /// Implement logic to execute when the Flow is started.
          override internal func didStart() {}
      }

      extension AppFlowImp: AppFlow {}
      extension AppFlowImp: AppFlowInterface {

          func attachScene(_ viewController: WindowSceneViewControllable) {
              let flow: SceneFlow = sceneBuilder.build(withListener: context,
                                                       viewController: viewController)
              attach(starting: flow)
          }

          func detachScene(_ viewController: WindowSceneViewControllable) {
              subFlows
                  .compactMap { $0 as? SceneFlow }
                  .filter { $0.viewControllable === viewController }
                  .forEach(detach)
          }
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/1 App/AppWorker.swift"
    contents: |
      //
      //  AppWorker.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       Encapsulates work to be performed by the Node.
       */
      internal protocol AppWorker: Worker {}

      /**
       PURPOSE:
       Concrete implementation of the Worker.
       */
      internal final class AppWorkerImp: AbstractWorker<AnyCancellable> {

          /// The Analytics instance.
          private let analytics: AppAnalytics

          /// The initializer.
          /// - Parameter analytics: The Analytics instance
          internal init(analytics: AppAnalytics) {
              self.analytics = analytics
          }

          /// Implement logic to execute when the Worker is started.
          override internal func didStart() {}

          /// Implement logic to execute when the Worker has stopped.
          override internal func willStop() {}
      }

      extension AppWorkerImp: AppWorker {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/2 Scene/SceneAnalytics.swift"
    contents: |
      //
      //  SceneAnalytics.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /*
       INSTRUCTIONS:

       Option 1
       ========
       Conform an existing analytics tracker (or client), that is defined outside of the Node, to the
       SceneAnalytics protocol.

       This option is preferred.

       When using this option, delete the class defined in this file (below).

       Option 2
       ========
       Inject an existing analytics tracker (or client), that is defined outside of the Node, into the
       class defined in this file (below).

       Only use this option if option 1 is not possible, for example, when the class defined in this
       file (below) is needed to store state (not recommended).

       When using this option, inject the tracker (or client) via a protocol. The protocol for the
       injected tracker (or client) can either be an existing one defined outside of the Node or
       can be a new one added to this file.
       */

      /**
       PURPOSE:
       The interface for analytics tracked by this Node.

       Whether using option 1 or 2, add requirements to this protocol to provide analytics tracking
       methods for this Node.
       */
      internal protocol SceneAnalytics: AnyObject {}

      /**
       PURPOSE:
       The implementations of the protocol methods for analytics tracked by this Node.

       If using option 1, add implementations for the methods defined in the protocol that are not
       implemented by the conforming tracker (or client).

       If using option 2, delete this extension.
       */
      internal extension SceneAnalytics {}

      /**
       PURPOSE:
       Custom analytics implementation for this Node, to be used ONLY when storing state is unavoidable.

       If using option 1, delete this class and extension below.
       */
      internal final class SceneAnalyticsImp {}

      extension SceneAnalyticsImp: SceneAnalytics {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/2 Scene/SceneBuilder.swift"
    contents: |
      //
      //  SceneBuilder.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import NeedleFoundation
      import Nodes

      /**
       PURPOSE:
       The interface of the Flow.
       */
      internal protocol SceneFlow: Flow {
          var viewControllable: WindowSceneViewControllable { get }
      }

      /**
       PURPOSE:
       Declares the dependencies required by this Node that will be injected (not created by this Node itself).
       */
      internal protocol SceneDependency: Dependency {}

      /**
       PURPOSE:
       A dependency needed by the Builder (such as a Listener), passed in from the caller (i.e. is not on the DI graph).

       Can be a tuple containing multiple values when necessary.
       */
      internal typealias SceneDynamicBuildDependency = (SceneListener, WindowSceneViewControllable)

      /**
       PURPOSE:
       A dependency used by the Component itself, passed into the Component's initializer (in the Component factory).

       Can be a tuple containing multiple values when necessary.
       */
      internal typealias SceneDynamicComponentDependency = Void

      // MARK: - Component

      /**
       PURPOSE:
       Declares dependencies that are owned by this Node.
       */
      internal final class SceneComponent: Component<SceneDependency> {

          /*
           Dependencies
           ============

           Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

           fileprivate let example: Example = .init()

           Whenever possible, for example when the dependency does not provide shared state, define the property as a
           factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
           Needle compatibility whenever the access control is increased.

           fileprivate var exampleFactory: Example {
               Example()
           }

           When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
           that always returns the same instance from a computed property.

           fileprivate var example: Example {
               shared { Example(otherDependency: dependency.otherDependency) }
           }

           */

          private let dynamicDependency: SceneDynamicComponentDependency

          /// The initializer.
          ///
          /// Remove `dynamicDependency` default parameter when its type is not `Void`.
          ///
          /// - Parameter parent: The parent scope
          /// - Parameter dynamicDependency: The dynamic component dependency
          internal init(parent: Scope, dynamicDependency: SceneDynamicComponentDependency = ()) {
              self.dynamicDependency = dynamicDependency
              super.init(parent: parent)
          }

          /*
           Child Components
           ================

           Declare child component factories as 'fileprivate' methods.

           fileprivate func childComponentFactory() -> ChildComponent {
               ChildComponent(parent: self)
           }

           */

          fileprivate func windowComponentFactory() -> WindowComponent {
              WindowComponent(parent: self)
          }
      }

      // MARK: - Builder

      /**
       PURPOSE:
       The Builder interface (available to mock for testability).
       */
      internal protocol SceneBuilder: AnyObject {
          func build(withListener listener: SceneListener,
                     viewController: WindowSceneViewControllable) -> SceneFlow
      }

      internal typealias SceneBuilderType = AbstractBuilder
          <
          SceneComponent,
          SceneFlow,
          SceneDynamicBuildDependency,
          SceneDynamicComponentDependency
          >

      /**
       PURPOSE:
       Concrete implementation of the Builder, where everything is created and associated.
       */
      internal final class SceneBuilderImp: SceneBuilderType {

          /// The purpose of this method is to route input parameters to either the dynamic build dependency and/or
          /// the dynamic component dependency.
          ///
          /// The dynamic dependencies can be tuples containing multiple values when necessary.
          /// - Parameter listener: An object that can listen for signals from the Node
          /// - Returns: The Flow instance
          internal func build(
              withListener listener: SceneListener,
              viewController: WindowSceneViewControllable
          ) -> SceneFlow {
              let dynamicBuildDependency: SceneDynamicBuildDependency = (listener, viewController)
              let dynamicComponentDependency: SceneDynamicComponentDependency = ()
              return build(dynamicBuildDependency, dynamicComponentDependency)
          }

          /// The factory method in which the Context and Flow are initialized.
          /// - Parameters:
          ///   - component: The component instance
          ///   - dynamicBuildDependency: The dynamic build dependency
          /// - Returns: The Flow instance
          override internal func build(
              component: SceneComponent,
              dynamicBuildDependency: SceneDynamicBuildDependency
          ) -> SceneFlow {
              let (listener, viewController) = dynamicBuildDependency
              let analytics: SceneAnalyticsImp = .init()
              let worker: SceneWorkerImp = .init(
                  analytics: analytics
              )
              let context: SceneContextImp = .init(
                  workers: [worker],
                  analytics: analytics
              )
              context.listener = listener
              return SceneFlowImp(
                  context: context,
                  viewController: viewController,
                  windowBuilder: WindowBuilderImp(componentFactory: component.windowComponentFactory)
              )
          }
      }

      extension SceneBuilderImp: SceneBuilder {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/2 Scene/SceneContext.swift"
    contents: |
      //
      //  SceneContext.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The Context delegates callbacks to its (external) Listener, typically the parent Context.
       */
      internal protocol SceneListener: AnyObject {}

      /**
       PURPOSE:
       The interface that the Context will speak to the Flow through. Used to initiate navigation as
       an example.
       */
      internal protocol SceneFlowInterface: Flow {}

      /**
       PURPOSE:
       Contains the business logic of the Node. The lifecycle of the Node is bookended between the
       `didBecomeActive` and `willResignActive` methods.
       */
      internal final class SceneContextImp: AbstractContext<AnyCancellable> {

          /// The Flow instance.
          internal weak var flow: SceneFlowInterface?

          /// The Listener instance.
          internal weak var listener: SceneListener?

          /// The Analytics instance.
          private let analytics: SceneAnalytics

          /// The initializer.
          /// - Parameters:
          ///   - workers: The Worker instances
          ///   - analytics: The Analytics instance
          internal init(
              workers: [Worker],
              analytics: SceneAnalytics
          ) {
              self.analytics = analytics
              super.init(workers: workers)
          }

          /// Implement logic to execute when the Context becomes active.
          override internal func didBecomeActive() {}

          /// Implement logic to execute when the Context will become inactive.
          override internal func willResignActive() {}

          deinit {
              LeakDetector.detect(analytics)
          }
      }

      extension SceneContextImp: SceneContextInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/2 Scene/SceneFlow.swift"
    contents: |
      //
      //  SceneFlow.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The interface that the Flow will speak to the Context through. Used for informing the Context of
       presentation lifecycle events, as an example.
       */
      internal protocol SceneContextInterface: Context, WindowListener {
          var flow: SceneFlowInterface? { get set }
          var listener: SceneListener? { get }
      }

      /**
       PURPOSE:
       Responsible for presenting views and starting child Flows, and should not contain business logic.
       */
      internal final class SceneFlowImp: AbstractFlow<SceneContextInterface, WindowSceneViewControllable> {

          /// Provides the parent Node with access to the View so it can be presented.
          internal var viewControllable: WindowSceneViewControllable {
              viewController
          }

          private let windowBuilder: WindowBuilder

          /// The initializer.
          ///
          /// Inject Plugins or Builders into the Flow in order to create sub-Flows.
          /// - Parameters:
          ///   - context: The Context instance
          ///   - viewController: The View Controller instance
          internal init(
              context: SceneContextInterface,
              viewController: WindowSceneViewControllable,
              windowBuilder: WindowBuilder
          ) {
              self.windowBuilder = windowBuilder
              super.init(context: context, viewController: viewController)
              context.flow = self
          }

          /// Implement logic to execute when the Flow is started.
          override internal func didStart() {
              attachWindow()
          }

          private func attachWindow() {
              let flow: WindowFlow = windowBuilder.build(withListener: context,
                                                         viewController: viewController.makeWindow())
              attach(starting: flow)
          }
      }

      extension SceneFlowImp: SceneFlow {}
      extension SceneFlowImp: SceneFlowInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/2 Scene/SceneWorker.swift"
    contents: |
      //
      //  SceneWorker.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       Encapsulates work to be performed by the Node.
       */
      internal protocol SceneWorker: Worker {}

      /**
       PURPOSE:
       Concrete implementation of the Worker.
       */
      internal final class SceneWorkerImp: AbstractWorker<AnyCancellable> {

          /// The Analytics instance.
          private let analytics: SceneAnalytics

          /// The initializer.
          /// - Parameter analytics: The Analytics instance
          internal init(analytics: SceneAnalytics) {
              self.analytics = analytics
          }

          /// Implement logic to execute when the Worker is started.
          override internal func didStart() {}

          /// Implement logic to execute when the Worker has stopped.
          override internal func willStop() {}
      }

      extension SceneWorkerImp: SceneWorker {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/3 Window/WindowAnalytics.swift"
    contents: |
      //
      //  WindowAnalytics.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /*
       INSTRUCTIONS:

       Option 1
       ========
       Conform an existing analytics tracker (or client), that is defined outside of the Node, to the
       WindowAnalytics protocol.

       This option is preferred.

       When using this option, delete the class defined in this file (below).

       Option 2
       ========
       Inject an existing analytics tracker (or client), that is defined outside of the Node, into the
       class defined in this file (below).

       Only use this option if option 1 is not possible, for example, when the class defined in this
       file (below) is needed to store state (not recommended).

       When using this option, inject the tracker (or client) via a protocol. The protocol for the
       injected tracker (or client) can either be an existing one defined outside of the Node or
       can be a new one added to this file.
       */

      /**
       PURPOSE:
       The interface for analytics tracked by this Node.

       Whether using option 1 or 2, add requirements to this protocol to provide analytics tracking
       methods for this Node.
       */
      internal protocol WindowAnalytics: AnyObject {}

      /**
       PURPOSE:
       The implementations of the protocol methods for analytics tracked by this Node.

       If using option 1, add implementations for the methods defined in the protocol that are not
       implemented by the conforming tracker (or client).

       If using option 2, delete this extension.
       */
      internal extension WindowAnalytics {}

      /**
       PURPOSE:
       Custom analytics implementation for this Node, to be used ONLY when storing state is unavoidable.

       If using option 1, delete this class and extension below.
       */
      internal final class WindowAnalyticsImp {}

      extension WindowAnalyticsImp: WindowAnalytics {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/3 Window/WindowBuilder.swift"
    contents: |
      //
      //  WindowBuilder.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import NeedleFoundation
      import Nodes

      /**
       PURPOSE:
       The interface of the Flow.
       */
      internal protocol WindowFlow: Flow {}

      /**
       PURPOSE:
       Declares the dependencies required by this Node that will be injected (not created by this Node itself).
       */
      internal protocol WindowDependency: Dependency {}

      /**
       PURPOSE:
       A dependency needed by the Builder (such as a Listener), passed in from the caller (i.e. is not on the DI graph).

       Can be a tuple containing multiple values when necessary.
       */
      internal typealias WindowDynamicBuildDependency = (WindowListener, WindowViewControllable)

      /**
       PURPOSE:
       A dependency used by the Component itself, passed into the Component's initializer (in the Component factory).

       Can be a tuple containing multiple values when necessary.
       */
      internal typealias WindowDynamicComponentDependency = Void

      // MARK: - Component

      /**
       PURPOSE:
       Declares dependencies that are owned by this Node.
       */
      internal final class WindowComponent: Component<WindowDependency> {

          /*
           Dependencies
           ============

           Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

           fileprivate let example: Example = .init()

           Whenever possible, for example when the dependency does not provide shared state, define the property as a
           factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
           Needle compatibility whenever the access control is increased.

           fileprivate var exampleFactory: Example {
               Example()
           }

           When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
           that always returns the same instance from a computed property.

           fileprivate var example: Example {
               shared { Example(otherDependency: dependency.otherDependency) }
           }

           */

          private let dynamicDependency: WindowDynamicComponentDependency

          /// The initializer.
          ///
          /// Remove `dynamicDependency` default parameter when its type is not `Void`.
          ///
          /// - Parameter parent: The parent scope
          /// - Parameter dynamicDependency: The dynamic component dependency
          internal init(parent: Scope, dynamicDependency: WindowDynamicComponentDependency = ()) {
              self.dynamicDependency = dynamicDependency
              super.init(parent: parent)
          }

          /*
           Child Components
           ================

           Declare child component factories as 'fileprivate' methods.

           fileprivate func childComponentFactory() -> ChildComponent {
               ChildComponent(parent: self)
           }

           */

          fileprivate func rootComponentFactory() -> RootComponent {
              RootComponent(parent: self)
          }
      }

      // MARK: - Builder

      /**
       PURPOSE:
       The Builder interface (available to mock for testability).
       */
      internal protocol WindowBuilder: AnyObject {
          func build(withListener listener: WindowListener,
                     viewController: WindowViewControllable) -> WindowFlow
      }

      internal typealias WindowBuilderType = AbstractBuilder
          <
          WindowComponent,
          WindowFlow,
          WindowDynamicBuildDependency,
          WindowDynamicComponentDependency
          >

      /**
       PURPOSE:
       Concrete implementation of the Builder, where everything is created and associated.
       */
      internal final class WindowBuilderImp: WindowBuilderType {

          /// The purpose of this method is to route input parameters to either the dynamic build dependency and/or
          /// the dynamic component dependency.
          ///
          /// The dynamic dependencies can be tuples containing multiple values when necessary.
          /// - Parameter listener: An object that can listen for signals from the Node
          /// - Returns: The Flow instance
          internal func build(
              withListener listener: WindowListener,
              viewController: WindowViewControllable
          ) -> WindowFlow {
              let dynamicBuildDependency: WindowDynamicBuildDependency = (listener, viewController)
              let dynamicComponentDependency: WindowDynamicComponentDependency = ()
              return build(dynamicBuildDependency, dynamicComponentDependency)
          }

          /// The factory method in which the Context and Flow are initialized.
          /// - Parameters:
          ///   - component: The component instance
          ///   - dynamicBuildDependency: The dynamic build dependency
          /// - Returns: The Flow instance
          override internal func build(
              component: WindowComponent,
              dynamicBuildDependency: WindowDynamicBuildDependency
          ) -> WindowFlow {
              let (listener, viewController) = dynamicBuildDependency
              let analytics: WindowAnalyticsImp = .init()
              let worker: WindowWorkerImp = .init(
                  analytics: analytics
              )
              let context: WindowContextImp = .init(
                  workers: [worker],
                  analytics: analytics
              )
              context.listener = listener
              return WindowFlowImp(
                  context: context,
                  viewController: viewController,
                  rootBuilder: RootBuilderImp(componentFactory: component.rootComponentFactory)
              )
          }
      }

      extension WindowBuilderImp: WindowBuilder {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/3 Window/WindowContext.swift"
    contents: |
      //
      //  WindowContext.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The Context delegates callbacks to its (external) Listener, typically the parent Context.
       */
      internal protocol WindowListener: AnyObject {}

      /**
       PURPOSE:
       The interface that the Context will speak to the Flow through. Used to initiate navigation as
       an example.
       */
      internal protocol WindowFlowInterface: Flow {}

      /**
       PURPOSE:
       Contains the business logic of the Node. The lifecycle of the Node is bookended between the
       `didBecomeActive` and `willResignActive` methods.
       */
      internal final class WindowContextImp: AbstractContext<AnyCancellable> {

          /// The Flow instance.
          internal weak var flow: WindowFlowInterface?

          /// The Listener instance.
          internal weak var listener: WindowListener?

          /// The Analytics instance.
          private let analytics: WindowAnalytics

          /// The initializer.
          /// - Parameters:
          ///   - workers: The Worker instances
          ///   - analytics: The Analytics instance
          internal init(
              workers: [Worker],
              analytics: WindowAnalytics
          ) {
              self.analytics = analytics
              super.init(workers: workers)
          }

          /// Implement logic to execute when the Context becomes active.
          override internal func didBecomeActive() {}

          /// Implement logic to execute when the Context will become inactive.
          override internal func willResignActive() {}

          deinit {
              LeakDetector.detect(analytics)
          }
      }

      extension WindowContextImp: WindowContextInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/3 Window/WindowFlow.swift"
    contents: |
      //
      //  WindowFlow.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The interface that the Flow will speak to the Context through. Used for informing the Context of
       presentation lifecycle events, as an example.
       */
      internal protocol WindowContextInterface: Context, RootListener {
          var flow: WindowFlowInterface? { get set }
          var listener: WindowListener? { get }
      }

      /**
       PURPOSE:
       Responsible for presenting views and starting child Flows, and should not contain business logic.
       */
      internal final class WindowFlowImp: AbstractFlow<WindowContextInterface, WindowViewControllable> {

          private let rootBuilder: RootBuilder

          /// The initializer.
          ///
          /// Inject Plugins or Builders into the Flow in order to create sub-Flows.
          /// - Parameters:
          ///   - context: The Context instance
          ///   - viewController: The View Controller instance
          internal init(
              context: WindowContextInterface,
              viewController: WindowViewControllable,
              rootBuilder: RootBuilder
          ) {
              self.rootBuilder = rootBuilder
              super.init(context: context, viewController: viewController)
              context.flow = self
          }

          /// Implement logic to execute when the Flow is started.
          override internal func didStart() {
              attachRoot()
          }

          private func attachRoot() {
              let flow: RootFlow = rootBuilder.build(withListener: context)
              viewController.present(flow.viewControllable)
              attach(starting: flow)
          }
      }

      extension WindowFlowImp: WindowFlow {}
      extension WindowFlowImp: WindowFlowInterface {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/3 Window/WindowWorker.swift"
    contents: |
      //
      //  WindowWorker.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       Encapsulates work to be performed by the Node.
       */
      internal protocol WindowWorker: Worker {}

      /**
       PURPOSE:
       Concrete implementation of the Worker.
       */
      internal final class WindowWorkerImp: AbstractWorker<AnyCancellable> {

          /// The Analytics instance.
          private let analytics: WindowAnalytics

          /// The initializer.
          /// - Parameter analytics: The Analytics instance
          internal init(analytics: WindowAnalytics) {
              self.analytics = analytics
          }

          /// Implement logic to execute when the Worker is started.
          override internal func didStart() {}

          /// Implement logic to execute when the Worker has stopped.
          override internal func willStop() {}
      }

      extension WindowWorkerImp: WindowWorker {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootAnalytics.swift"
    contents: |
      //
      //  RootAnalytics.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /*
       INSTRUCTIONS:

       Option 1
       ========
       Conform an existing analytics tracker (or client), that is defined outside of the Node, to the
       RootAnalytics protocol.

       This option is preferred.

       When using this option, delete the class defined in this file (below).

       Option 2
       ========
       Inject an existing analytics tracker (or client), that is defined outside of the Node, into the
       class defined in this file (below).

       Only use this option if option 1 is not possible, for example, when the class defined in this
       file (below) is needed to store state (not recommended).

       When using this option, inject the tracker (or client) via a protocol. The protocol for the
       injected tracker (or client) can either be an existing one defined outside of the Node or
       can be a new one added to this file.
       */

      /**
       PURPOSE:
       The interface for analytics tracked by this Node.

       Whether using option 1 or 2, add requirements to this protocol to provide analytics tracking
       methods for this Node.
       */
      internal protocol RootAnalytics: AnyObject {}

      /**
       PURPOSE:
       The implementations of the protocol methods for analytics tracked by this Node.

       If using option 1, add implementations for the methods defined in the protocol that are not
       implemented by the conforming tracker (or client).

       If using option 2, delete this extension.
       */
      internal extension RootAnalytics {}

      /**
       PURPOSE:
       Custom analytics implementation for this Node, to be used ONLY when storing state is unavoidable.

       If using option 1, delete this class and extension below.
       */
      internal final class RootAnalyticsImp {}

      extension RootAnalyticsImp: RootAnalytics {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootBuilder.swift"
    contents: |
      //
      //  RootBuilder.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import NeedleFoundation
      import Nodes

      /**
       PURPOSE:
       The interface of the Flow.
       */
      internal protocol RootFlow: ViewControllableFlow {}

      /**
       PURPOSE:
       Declares the dependencies required by this Node that will be injected (not created by this Node itself).
       */
      internal protocol RootDependency: Dependency {}

      /**
       PURPOSE:
       A dependency needed by the Builder (such as a Listener), passed in from the caller (i.e. is not on the DI graph).

       Can be a tuple containing multiple values when necessary.
       */
      internal typealias RootDynamicBuildDependency = RootListener

      /**
       PURPOSE:
       A dependency used by the Component itself, passed into the Component's initializer (in the Component factory).

       Can be a tuple containing multiple values when necessary.
       */
      internal typealias RootDynamicComponentDependency = Void

      // MARK: - Component

      /**
       PURPOSE:
       Declares dependencies that are owned by this Node.
       */
      internal final class RootComponent: Component<RootDependency> {

          /*
           Dependencies
           ============

           Declare dependencies as 'fileprivate' properties (increasing access control only as necessary).

           fileprivate let example: Example = .init()

           Whenever possible, for example when the dependency does not provide shared state, define the property as a
           factory that always returns a new instance. Factory properties are preferred over factory methods to ensure
           Needle compatibility whenever the access control is increased.

           fileprivate var exampleFactory: Example {
               Example()
           }

           When shared state is desired but the dependency depends on another dependency, use the `shared` helper method
           that always returns the same instance from a computed property.

           fileprivate var example: Example {
               shared { Example(otherDependency: dependency.otherDependency) }
           }

           */

          private let dynamicDependency: RootDynamicComponentDependency

          /// The initializer.
          ///
          /// Remove `dynamicDependency` default parameter when its type is not `Void`.
          ///
          /// - Parameter parent: The parent scope
          /// - Parameter dynamicDependency: The dynamic component dependency
          internal init(parent: Scope, dynamicDependency: RootDynamicComponentDependency = ()) {
              self.dynamicDependency = dynamicDependency
              super.init(parent: parent)
          }

          /*
           Child Components
           ================

           Declare child component factories as 'fileprivate' methods.

           fileprivate func childComponentFactory() -> ChildComponent {
               ChildComponent(parent: self)
           }

           */
      }

      // MARK: - Builder

      /**
       PURPOSE:
       The Builder interface (available to mock for testability).
       */
      internal protocol RootBuilder: AnyObject {
          func build(withListener listener: RootListener) -> RootFlow
      }

      internal typealias RootBuilderType = AbstractBuilder
          <
          RootComponent,
          RootFlow,
          RootDynamicBuildDependency,
          RootDynamicComponentDependency
          >

      /**
       PURPOSE:
       Concrete implementation of the Builder, where everything is created and associated.
       */
      internal final class RootBuilderImp: RootBuilderType {

          /// The purpose of this method is to route input parameters to either the dynamic build dependency and/or
          /// the dynamic component dependency.
          ///
          /// The dynamic dependencies can be tuples containing multiple values when necessary.
          /// - Parameter listener: An object that can listen for signals from the Node
          /// - Returns: The Flow instance
          internal func build(withListener listener: RootListener) -> RootFlow {
              let dynamicBuildDependency: RootDynamicBuildDependency = listener
              let dynamicComponentDependency: RootDynamicComponentDependency = ()
              return build(dynamicBuildDependency, dynamicComponentDependency)
          }

          /// The factory method in which the Context and Flow are initialized.
          /// - Parameters:
          ///   - component: The component instance
          ///   - dynamicBuildDependency: The dynamic build dependency
          /// - Returns: The Flow instance
          override internal func build(
              component: RootComponent,
              dynamicBuildDependency: RootDynamicBuildDependency
          ) -> RootFlow {
              let listener: RootListener = dynamicBuildDependency
              let analytics: RootAnalyticsImp = .init()
              let worker: RootWorkerImp = .init(
                  analytics: analytics
              )
              let viewController: RootViewController = .init()
              viewController.analytics = analytics
              let context: RootContextImp = .init(
                  presentable: viewController,
                  workers: [worker],
                  analytics: analytics
              )
              context.listener = listener
              return RootFlowImp(
                  context: context,
                  viewController: viewController
              )
          }
      }

      extension RootBuilderImp: RootBuilder {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootContext.swift"
    contents: |
      //
      //  RootContext.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The Context delegates callbacks to its (external) Listener, typically the parent Context.
       */
      internal protocol RootListener: AnyObject {}

      /**
       PURPOSE:
       The interface that the Context will speak to the Flow through. Used to initiate navigation as
       an example.
       */
      internal protocol RootFlowInterface: Flow {
          func didBecomeReady()
      }

      /**
       PURPOSE:
       The interface that the Context will speak to the View through. Used to inform the View of any
       state change (i.e. to keep the UI in sync).
       */
      internal protocol RootPresentable: AnyObject {
          var receiver: RootReceiver? { get set }
      }

      /**
       PURPOSE:
       Contains the business logic of the Node. The lifecycle of the Node is bookended between the
       `didBecomeActive` and `willResignActive` methods.
       */
      internal final class RootContextImp: AbstractPresentableContext<AnyCancellable, RootPresentable> {

          /// The Flow instance.
          internal weak var flow: RootFlowInterface?

          /// The Listener instance.
          internal weak var listener: RootListener?

          /// The Analytics instance.
          private let analytics: RootAnalytics

          private var isReady: Bool = false

          /// The initializer.
          /// - Parameters:
          ///   - presentable: The Presentable instance
          ///   - workers: The Worker instances
          ///   - analytics: The Analytics instance
          internal init(
              presentable: RootPresentable,
              workers: [Worker],
              analytics: RootAnalytics
          ) {
              self.analytics = analytics
              super.init(presentable: presentable, workers: workers)
              presentable.receiver = self
          }

          /// Implement logic to execute when the Context becomes active.
          override internal func didBecomeActive() {}

          /// Implement logic to execute when the Context will become inactive.
          override internal func willResignActive() {}

          deinit {
              LeakDetector.detect(analytics)
          }
      }

      extension RootContextImp: RootContextInterface {}
      extension RootContextImp: RootReceiver {

          internal func viewDidAppear() {
              guard !isReady
              else { return }
              isReady = true
              flow?.didBecomeReady()
          }
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootFlow.swift"
    contents: |
      //
      //  RootFlow.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       The interface that the Flow will speak to the Context through. Used for informing the Context of
       presentation lifecycle events, as an example.
       */
      internal protocol RootContextInterface: Context {
          var flow: RootFlowInterface? { get set }
          var listener: RootListener? { get }
      }

      /**
       PURPOSE:
       The interface of the View used for presenting the View of child Nodes. May inherit additional base
       protocols to add further pre-baked presentation behavior and/or add new methods for custom presentation
       implementation as necessary.
       */
      internal protocol RootViewControllable: ViewControllable {}

      /**
       PURPOSE:
       Responsible for presenting views and starting child Flows, and should not contain business logic.
       */
      internal final class RootFlowImp: AbstractFlow<RootContextInterface, RootViewControllable> {

          /// Provides the parent Node with access to the View so it can be presented.
          internal var viewControllable: ViewControllable {
              viewController
          }

          /// The initializer.
          ///
          /// Inject Plugins or Builders into the Flow in order to create sub-Flows.
          /// - Parameters:
          ///   - context: The Context instance
          ///   - viewController: The View Controller instance
          override internal init(
              context: RootContextInterface,
              viewController: RootViewControllable
          ) {
              super.init(context: context, viewController: viewController)
              context.flow = self
          }

          /// Implement logic to execute when the Flow is started.
          override internal func didStart() {}
      }

      extension RootFlowImp: RootFlow {}
      extension RootFlowImp: RootFlowInterface {

          /// Implement logic to execute when the Root Flow is ready to attach child Flows.
          internal func didBecomeReady() {}
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootViewController.swift"
    contents: |
      //
      //  RootViewController.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes
      import UIKit

      /**
       PURPOSE:
       The interface that the View will speak to the Context through. Used for informing the Context of
       view events and user interactions.
       */
      internal protocol RootReceiver: AnyObject {
          func viewDidAppear()
      }

      /**
       PURPOSE:
       Concrete implementation of the UI.
       */
      internal final class RootViewController: UIViewController {

          /// The view receiver.
          internal weak var receiver: RootReceiver?

          /// The Analytics instance.
          internal weak var analytics: RootAnalytics?

          private let label: UILabel = {
              let label: UILabel = .init()
              label.translatesAutoresizingMaskIntoConstraints = false
              label.text = "{{ project }}"
              return label
          }()

          /// The initializer.
          internal init() {
              super.init(nibName: nil, bundle: nil)
          }

          @available(*, unavailable)
          internal required init?(coder: NSCoder) {
              preconditionFailure("init(coder:) has not been implemented")
          }

          override func viewDidLoad() {
              super.viewDidLoad()
              view.backgroundColor = .systemBackground
              view.addSubview(label)
              view.addConstraints([
                  label.centerXAnchor.constraint(equalTo: view.centerXAnchor),
                  label.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: -20)
              ])
          }

          override func viewDidAppear(_ animated: Bool) {
              super.viewDidAppear(animated)
              receiver?.viewDidAppear()
          }
      }

      extension RootViewController: RootViewControllable {}
      extension RootViewController: RootPresentable {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/4 Root/RootWorker.swift"
    contents: |
      //
      //  RootWorker.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      /**
       PURPOSE:
       Encapsulates work to be performed by the Node.
       */
      internal protocol RootWorker: Worker {}

      /**
       PURPOSE:
       Concrete implementation of the Worker.
       */
      internal final class RootWorkerImp: AbstractWorker<AnyCancellable> {

          /// The Analytics instance.
          private let analytics: RootAnalytics

          /// The initializer.
          /// - Parameter analytics: The Analytics instance
          internal init(analytics: RootAnalytics) {
              self.analytics = analytics
          }

          /// Implement logic to execute when the Worker is started.
          override internal func didStart() {}

          /// Implement logic to execute when the Worker has stopped.
          override internal func willStop() {}
      }

      extension RootWorkerImp: RootWorker {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/Services/AppService.swift"
    contents: |
      //
      //  AppService.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import UIKit

      /// @mockable
      internal protocol AppService {
          var windowSceneState: AnyPublisher<WindowSceneState, Never> { get }
      }

      internal final class AppServiceImp: AppService {

          internal var windowSceneState: AnyPublisher<WindowSceneState, Never> {
              Publishers.Merge(
                  notificationCenter
                      .publisher(for: UIScene.willConnectNotification)
                      .compactMap { $0.object as? UIWindowScene }
                      .map { .added($0) },
                  notificationCenter
                      .publisher(for: UIScene.didDisconnectNotification)
                      .compactMap { $0.object as? UIWindowScene }
                      .map { .removed($0) })
              .eraseToAnyPublisher()
          }

          private let notificationCenter: NotificationCenter

          internal init(notificationCenter: NotificationCenter = Foundation.NotificationCenter.default) {
              self.notificationCenter = notificationCenter
          }
      }

      internal enum WindowSceneState {

          case added(UIWindowScene)
          case removed(UIWindowScene)

          internal var isAdded: Bool {
              guard case .added = self
              else { return false }
              return true
          }

          internal var isRemoved: Bool {
              guard case .removed = self
              else { return false }
              return true
          }

          internal var windowScene: UIWindowScene {
              switch self {
              case let .added(windowScene):
                  return windowScene
              case let .removed(windowScene):
                  return windowScene
              }
          }
      }

  - path: "{{ project|split:' '|join:'_' }}/Sources/System/NotificationCenter.swift"
    contents: |
      //
      //  NotificationCenter.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Foundation

      /// @mockable(module: prefix = {{ project|split:' '|join:'_' }})
      protocol NotificationCenter {
          func publisher(for name: Notification.Name, object: AnyObject?) -> Foundation.NotificationCenter.Publisher
      }

      extension NotificationCenter {

          internal func publisher(for name: Notification.Name) -> Foundation.NotificationCenter.Publisher {
              publisher(for: name, object: nil)
          }
      }

      extension Foundation.NotificationCenter: NotificationCenter {}

  - path: "{{ project|split:' '|join:'_' }}/Sources/Utility/AnyCancellable+Cancellable.swift"
    contents: |
      //
      //  AnyCancellable+Cancellable.swift
      //  {{ project|split:' '|join:'_' }}
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import Combine
      import Nodes

      extension Combine.AnyCancellable: Nodes.Cancellable {}

  - path: "{{ project|split:' '|join:'_' }}Tests/BuildSettings/Debug.xcconfig"
    contents: |
      #include "Shared.xcconfig"

  - path: "{{ project|split:' '|join:'_' }}Tests/BuildSettings/Release.xcconfig"
    contents: |
      #include "Shared.xcconfig"

  - path: "{{ project|split:' '|join:'_' }}Tests/BuildSettings/Shared.xcconfig"
    contents: |
      ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES
      BUNDLE_LOADER = $(TEST_HOST)
      CODE_SIGN_STYLE = Automatic
      LD_RUNPATH_SEARCH_PATHS = $(inherited) @executable_path/Frameworks @loader_path/Frameworks
      PRODUCT_NAME = $(TARGET_NAME)
      SWIFT_VERSION = 5.0
      TARGETED_DEVICE_FAMILY = 1,2
      TEST_HOST = $(BUILT_PRODUCTS_DIR)/{{ project|split:' '|join:'_' }}.app/{{ project|split:' '|join:'_' }}

  - path: "{{ project|split:' '|join:'_' }}Tests/Generated/.gitignore"
    contents: |
      *
      !.gitignore

  - path: "{{ project|split:' '|join:'_' }}Tests/Tests/{{ project|split:' '|join:'_' }}Tests.swift"
    contents: |
      //
      //  {{ project|split:' '|join:'_' }}Tests.swift
      //  {{ project|split:' '|join:'_' }}Tests
      //
      //  Created by {{ author }} on {{ date }}.
      //

      import XCTest

      class {{ project|split:' '|join:'_' }}Tests: XCTestCase {}

  - path: Package.swift
    contents: |
      // swift-tools-version:5.6

      import PackageDescription

      let package = Package(
          name: "{{ project|split:' '|join:'_' }}",
          products: [],
          dependencies: [
              .package(
                  url: "git@github.com:TinderApp/Nodes.git",
                  from: "0.0.0"),
          ],
          targets: []
      )

  - path: project.yml
    contents: |
      name: {{ project|split:' '|join:'_' }}
      options:
        bundleIdPrefix: {{ prefix }}
        deploymentTarget:
          iOS: "15.0"
        defaultConfig: Release
        settingPresets: none
        usesTabs: false
        tabWidth: 4
        indentWidth: 4
        preGenCommand: |
          set -e
          WORKSPACE_DOCUMENT_NAME="{{ project|split:' '|join:'_' }}.xcodeproj"
          osascript \
              -e 'set workspaceDocumentName to "'"${WORKSPACE_DOCUMENT_NAME}"'"' \
              -e 'if application id "com.apple.dt.Xcode" is running then' \
              -e 'tell application id "com.apple.dt.Xcode"' \
              -e 'if workspace document workspaceDocumentName exists then' \
              -e 'set workspaceDocument to workspace document workspaceDocumentName' \
              -e 'if loaded of workspaceDocument is false then' \
              -e 'error "workspace not loaded"' \
              -e 'end if' \
              -e 'log "⚙️  Closing project..."' \
              -e 'tell workspaceDocument' \
              -e 'stop it' \
              -e 'delay 0.5' \
              -e 'close it' \
              -e 'end tell' \
              -e 'activate' \
              -e 'delay 1.5' \
              -e 'end if' \
              -e 'end tell' \
              -e 'end if'
          unset WORKSPACE_DOCUMENT_NAME
          NEEDLE_GENERATED="{{ project|split:' '|join:'_' }}/Generated/NeedleGenerated.swift"
          MOCKOLO_GENERATED="{{ project|split:' '|join:'_' }}Tests/Generated/MockoloGenerated.swift"
          [[ -f "${NEEDLE_GENERATED}" ]] || touch "${NEEDLE_GENERATED}"
          [[ -f "${MOCKOLO_GENERATED}" ]] || touch "${MOCKOLO_GENERATED}"
          unset NEEDLE_GENERATED MOCKOLO_GENERATED
        postGenCommand: |
          set -e
          swift run -- nodes-xcode-templates-gen --id "Xcode Templates"
          xed {{ project|split:' '|join:'_' }}.xcodeproj
      packages:
        Nodes:
          url: git@github.com:TinderApp/Nodes.git
          from: 0.0.0
        NeedleFoundation:
          url: https://github.com/uber/needle.git
          from: 0.18.0
      configFiles:
        Debug: BuildSettings/Debug.xcconfig
        Release: BuildSettings/Release.xcconfig
      fileGroups:
        - BuildSettings
      targets:
        {{ project|split:' '|join:'_' }}:
          type: application
          platform: iOS
          dependencies:
            - package: Nodes
            - package: NeedleFoundation
          preBuildScripts:
            - name: Needle
              script: >
                env SOURCEKIT_LOGGING=0
                needle generate {{ project|split:' '|join:'_' }}/Generated/NeedleGenerated.swift
                {{ project|split:' '|join:'_' }}/Sources
          sources: {{ project|split:' '|join:'_' }}
          scheme:
            testTargets:
              - {{ project|split:' '|join:'_' }}Tests
          configFiles:
            Debug: {{ project|split:' '|join:'_' }}/BuildSettings/Debug.xcconfig
            Release: {{ project|split:' '|join:'_' }}/BuildSettings/Release.xcconfig
          info:
            path: {{ project|split:' '|join:'_' }}/Generated/Info.plist
            properties:
              CFBundleDevelopmentRegion: $(DEVELOPMENT_LANGUAGE)
              CFBundleDisplayName: {{ project|split:' '|join:'_' }}
              CFBundleExecutable: $(EXECUTABLE_NAME)
              CFBundleIdentifier: $(PRODUCT_BUNDLE_IDENTIFIER)
              CFBundleInfoDictionaryVersion: "6.0"
              CFBundleName: $(PRODUCT_NAME)
              CFBundlePackageType: $(PRODUCT_BUNDLE_PACKAGE_TYPE)
              CFBundleShortVersionString: "1.0"
              CFBundleVersion: "1"
              LSRequiresIPhoneOS: true
              UIApplicationSceneManifest:
                UIApplicationSupportsMultipleScenes: true
                UISceneConfigurations:
                  UIWindowSceneSessionRoleApplication:
                    - UISceneConfigurationName: Default Configuration
                      UISceneDelegateClassName: $(PRODUCT_MODULE_NAME).SceneDelegate
              UIApplicationSupportsIndirectInputEvents: true
              UILaunchStoryboardName: LaunchScreen
              UIRequiredDeviceCapabilities:
                - armv7
              UISupportedInterfaceOrientations:
                - UIInterfaceOrientationPortrait
                - UIInterfaceOrientationLandscapeLeft
                - UIInterfaceOrientationLandscapeRight
              UISupportedInterfaceOrientations~ipad:
                - UIInterfaceOrientationPortrait
                - UIInterfaceOrientationPortraitUpsideDown
                - UIInterfaceOrientationLandscapeLeft
                - UIInterfaceOrientationLandscapeRight
        {{ project|split:' '|join:'_' }}Tests:
          type: bundle.unit-test
          platform: iOS
          dependencies:
            - target: {{ project|split:' '|join:'_' }}
            - package: Nodes
              product: NodesTesting
          preBuildScripts:
            - name: Mockolo
              script: >
                mockolo
                -d {{ project|split:' '|join:'_' }}Tests/Generated/MockoloGenerated.swift
                -i {{ project|split:' '|join:'_' }}
                -s {{ project|split:' '|join:'_' }}/Sources
                -s ${BUILD_DIR%Build/*}/SourcePackages/checkouts/Nodes/Sources/Nodes
                --custom-imports Nodes
          sources: {{ project|split:' '|join:'_' }}Tests
          configFiles:
            Debug: {{ project|split:' '|join:'_' }}Tests/BuildSettings/Debug.xcconfig
            Release: {{ project|split:' '|join:'_' }}Tests/BuildSettings/Release.xcconfig
          info:
            path: {{ project|split:' '|join:'_' }}Tests/Generated/Info.plist
            properties:
              CFBundleDevelopmentRegion: $(DEVELOPMENT_LANGUAGE)
              CFBundleExecutable: $(EXECUTABLE_NAME)
              CFBundleIdentifier: $(PRODUCT_BUNDLE_IDENTIFIER)
              CFBundleInfoDictionaryVersion: "6.0"
              CFBundleName: $(PRODUCT_NAME)
              CFBundlePackageType: $(PRODUCT_BUNDLE_PACKAGE_TYPE)
              CFBundleShortVersionString: "1.0"
              CFBundleVersion: "1"
